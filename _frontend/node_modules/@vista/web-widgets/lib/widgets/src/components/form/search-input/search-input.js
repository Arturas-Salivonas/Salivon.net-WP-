var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import Fuse from 'fuse.js';
import * as React from 'react';
import { Input } from '../input/input';
/**
 * Renders the search input component
 */
var SearchInput = /** @class */ (function (_super) {
    __extends(SearchInput, _super);
    function SearchInput(props) {
        var _this = _super.call(this, props) || this;
        _this.searchResult = undefined;
        _this.handleChange = function (newValue) {
            _this.setState({ searchTerm: newValue });
            _this.search(newValue, _this.props.searchValues);
            if (_this.props.onSearchTermChanged)
                _this.props.onSearchTermChanged(newValue);
        };
        _this.search = function (searchTerm, searchValues) {
            var results = searchTerm.trim().length === 0
                ? searchValues
                : _this.fuse.search(searchTerm);
            if (!_this.areResultsEqual(results, _this.searchResult)) {
                _this.searchResult = results;
                _this.props.onResultsChanged(results);
            }
        };
        _this.state = {
            searchTerm: '',
        };
        return _this;
    }
    SearchInput.prototype.render = function () {
        return (React.createElement(Input, __assign({}, this.props, { value: this.state.searchTerm, onChangeValue: this.handleChange })));
    };
    SearchInput.prototype.componentDidMount = function () {
        this.init(this.props);
    };
    SearchInput.prototype.componentDidUpdate = function (prevProps) {
        if (this.hasSearchPropsChanged(prevProps)) {
            this.init(this.props);
        }
    };
    SearchInput.prototype.hasSearchPropsChanged = function (prevProps) {
        return this.props.searchValues !== prevProps.searchValues ||
            this.props.searchOptions !== prevProps.searchOptions ||
            this.props.searchKeys !== prevProps.searchKeys;
    };
    SearchInput.prototype.init = function (props) {
        var searchValues = props.searchValues, searchOptions = props.searchOptions;
        this.fuse = new Fuse(searchValues, __assign({ shouldSort: true, threshold: 0.4, location: 0, distance: 100, maxPatternLength: 32, minMatchCharLength: 1, keys: props.searchKeys }, searchOptions));
        this.search(this.state.searchTerm, props.searchValues);
    };
    SearchInput.prototype.areResultsEqual = function (newResults, oldResults) {
        if (!oldResults || oldResults.length !== newResults.length)
            return false;
        return oldResults.every(function (result, index) { return newResults[index] === result; });
    };
    return SearchInput;
}(React.Component));
export { SearchInput };
//# sourceMappingURL=search-input.js.map