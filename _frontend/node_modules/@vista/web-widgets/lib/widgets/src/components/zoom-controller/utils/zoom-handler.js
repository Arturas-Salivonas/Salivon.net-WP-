var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import { Animator } from '../../../dom/animator';
import { clamp } from './clamp';
import { MouseRecognizer } from './input-recognition/mouse-recognizer';
import { TouchRecognizer } from './input-recognition/touch-recognizer';
import { addPoints, centerPoint, scalePoint, subtractPoints } from './measurement-utils';
import { getRelativePoint } from './window-utils';
var ZoomHandler = /** @class */ (function () {
    /**
     * Creates a zoom handler and registers required input recognizer callbacks.
     */
    function ZoomHandler() {
        var _this = this;
        /**
         * Threshold of the minimum initial scale required for tap to zoom to be enabled.
         */
        this.tapToZoomScaleThreshold = 0.75;
        /**
         * Zoom scale increment used for the zoomIn and zoomOut functions.
         */
        this.zoomIncrement = 1.5;
        /**
         * Pan increment used for panUp, panRight, panDown and panLeft functions.
         */
        this.panIncrement = 100;
        /**
         * Duration of animation of zoom and pan changes. Does not apply to click/tap and drag events.
         */
        this.animationDuration = 100;
        /**
         * Extra padding to allow the user to pan past the zoom buttons.
         */
        this.zoomButtonPadding = 44;
        /**
         * Maximum scale of the content element.
         */
        this.maxScale = 1;
        /**
         * Recognizer for touch events.
         */
        this.touchRecognizer = new TouchRecognizer();
        /**
         * Recognizer for mouse events.
         */
        this.mouseRecognizer = new MouseRecognizer();
        /**
         * Zooms in to the center of the viewport by the zoomIncrement.
         */
        this.zoomIn = function () {
            var transform = _this.getZoomTransform(_this.zoomIncrement, _this.getViewportCenterPoint());
            _this.animateContentTransformation(transform);
        };
        /**
         * Zooms out from the center of the viewport by the zoomIncrement.
         */
        this.zoomOut = function () {
            var transform = _this.getZoomTransform(1 / _this.zoomIncrement, _this.getViewportCenterPoint());
            _this.animateContentTransformation(transform);
        };
        /**
         * Pans the content to a given x and y position.
         * @returns A boolean indicating whether any pan occurred.
         */
        this.panTo = function (point, animate) {
            if (animate === void 0) { animate = false; }
            var targetTranslation = _this.restrictTranslation(point, _this.getCurrentTotalScale());
            var currentTranslation = _this.currentContentTransformation.translation;
            var contentWasPanned = currentTranslation.x !== targetTranslation.x ||
                currentTranslation.y !== targetTranslation.y;
            if (contentWasPanned) {
                var transform = { translation: targetTranslation };
                if (animate)
                    _this.animateContentTransformation(transform);
                else
                    _this.applyContentTransformation(transform, true);
            }
            return contentWasPanned;
        };
        /**
         * Pans the content by a given translation amount.
         * @returns A boolean indicating whether any pan occurred.
         */
        this.panBy = function (translation, animate) {
            if (animate === void 0) { animate = false; }
            var newTranslation = addPoints(_this.currentContentTransformation.translation, translation);
            return _this.panTo(newTranslation, animate);
        };
        /**
         * Pans the content upwards by the panIncrement.
         */
        this.panUp = function () { return _this.panBy({ x: 0, y: _this.panIncrement }, true); };
        /**
         * Pans the content downwards by the panIncrement.
         */
        this.panDown = function () { return _this.panBy({ x: 0, y: -_this.panIncrement }, true); };
        /**
         * Pans the content left by the panIncrement.
         */
        this.panLeft = function () { return _this.panBy({ x: _this.panIncrement, y: 0 }, true); };
        /**
         * Pans the content right by the panIncrement.
         */
        this.panRight = function () { return _this.panBy({ x: -_this.panIncrement, y: 0 }, true); };
        /**
         * Zooms by a given scale around a given center point.
         */
        this.handlePinch = function (pinchScale, pinchCenter) {
            var relativePoint = getRelativePoint(pinchCenter, _this.viewport);
            var zoomTransform = _this.getZoomTransform(pinchScale / _this.currentContentTransformation.deltaScale, relativePoint);
            _this.applyContentTransformation(zoomTransform, true);
        };
        /**
         * Gets the transformation result of a zoom action.
         */
        this.getZoomTransform = function (zoomAmount, center) {
            var newScale = _this.restrictScale(_this.getCurrentTotalScale() * zoomAmount);
            // Get the zoom center point relative to the content
            var contentPoint = subtractPoints(center, _this.currentContentTransformation.translation);
            // Work out the size of the content with the new scaling
            var inversePreviousScale = scalePoint(1 / _this.getCurrentTotalScale());
            var applyNewScale = scalePoint(newScale);
            var contentPointWithNewScale = applyNewScale(inversePreviousScale(contentPoint));
            // Calculate transforms
            var newTranslation = _this.restrictTranslation(subtractPoints(center, contentPointWithNewScale), newScale);
            return {
                scale: newScale,
                translation: newTranslation
            };
        };
        /**
         * Returns the current total content scale.
         */
        this.getCurrentTotalScale = function () { return _this.currentContentTransformation.scale * _this.currentContentTransformation.deltaScale; };
        /**
         * Restricts a given translation by the translation limits.
         */
        this.restrictTranslation = function (translation, scale) {
            var _a = _this.getTranslationLimits(scale), minX = _a.minX, minY = _a.minY, maxX = _a.maxX, maxY = _a.maxY;
            return {
                x: clamp(minX, maxX)(translation.x),
                y: clamp(minY, maxY)(translation.y)
            };
        };
        /**
         * Returns the minimum and maximum x and y translation values.
         */
        this.getTranslationLimits = function (scale) {
            var contentDimensions = _this.calculateContentDimensionsAtScale(scale);
            var minX;
            var maxX;
            var minY;
            var maxY;
            if (_this.viewportDimensions.width >= contentDimensions.width) {
                minX = (_this.viewportDimensions.width - contentDimensions.width) / 2;
                maxX = minX;
            }
            else {
                minX = _this.viewportDimensions.width - contentDimensions.width - _this.zoomButtonPadding;
                maxX = 0;
            }
            if (_this.viewportDimensions.height >= contentDimensions.height) {
                minY = (_this.viewportDimensions.height - contentDimensions.height) / 2;
                maxY = minY;
            }
            else {
                minY = _this.viewportDimensions.height - contentDimensions.height;
                maxY = 0;
            }
            return {
                minX: minX,
                minY: minY,
                maxX: maxX,
                maxY: maxY
            };
        };
        /**
         * Applies a given transformation to the content element.
         */
        this.applyContentTransformation = function (transformation, fastScale) {
            var contentTransformation = __assign({}, _this.currentContentTransformation);
            if (transformation.translation) {
                contentTransformation.translation = transformation.translation;
            }
            if (transformation.scale) {
                contentTransformation.scale = fastScale ? _this.currentContentTransformation.scale : transformation.scale;
                contentTransformation.deltaScale = fastScale ? transformation.scale / _this.currentContentTransformation.scale : 1;
            }
            _this.currentContentTransformation = contentTransformation;
            _this.updatePanAvailability();
            _this.updateZoomAvailability();
            requestAnimationFrame(function () { return _this.setContentStyles(contentTransformation); });
        };
        /**
         * Animates a content transformation.
         */
        this.animateContentTransformation = function (transform) {
            if (_this.animator)
                _this.animator.cancel();
            var startTransformation = {
                translation: _this.currentContentTransformation.translation,
                scale: _this.getCurrentTotalScale()
            };
            var endTransformation = {
                translation: transform.translation || startTransformation.translation,
                scale: transform.scale || startTransformation.scale
            };
            _this.animator = new Animator(startTransformation, endTransformation, _this.animationDuration, _this.applyAnimationFrameContentTransformation);
            // Start the animation.
            _this.animator.start();
        };
        /**
         * Applies the content transformation at a given animation frame.
         */
        this.applyAnimationFrameContentTransformation = function (frame) {
            var progress = frame.progress, isFinalFrame = frame.isFinalFrame, startState = frame.startState, endState = frame.endState;
            if (isFinalFrame) {
                _this.applyContentTransformation(frame.endState, false);
                _this.animator = undefined;
                return;
            }
            var changeInTranslation = scalePoint(progress)(subtractPoints(endState.translation, startState.translation));
            var changeInScale = (endState.scale - startState.scale) * progress;
            var deltaScale = (startState.scale + changeInScale) / startState.scale;
            var transientTransform = {
                scale: startState.scale,
                deltaScale: deltaScale,
                translation: addPoints(startState.translation, changeInTranslation)
            };
            _this.currentContentTransformation = transientTransform;
            _this.setContentStyles(transientTransform);
        };
        /**
         * Sets the content styles based on a given transformation.
         */
        this.setContentStyles = function (transformation) {
            var scale = transformation.scale, deltaScale = transformation.deltaScale, translation = transformation.translation;
            var contentDimensions = _this.calculateContentDimensionsAtScale(scale);
            _this.content.setAttribute('style', "transform: translate3d(" + Math.floor(translation.x) + "px, " + Math.floor(translation.y) + "px, 0) " +
                ("scale3d(" + deltaScale + ", " + deltaScale + ", " + deltaScale + "); ") +
                ("width: " + Math.floor(contentDimensions.width) + "px; ") +
                ("height: " + Math.floor(contentDimensions.height) + "px;"));
            if (_this.onContentTransformationChanged)
                _this.onContentTransformationChanged(transformation);
        };
        /**
         * Updates the pan availability based on the current transformations.
         */
        this.updatePanAvailability = function () {
            if (!_this.onPanAvailabilityChanged)
                return; // nobody cares, no need to update
            var _a = _this.getTranslationLimits(_this.currentContentTransformation.scale), minX = _a.minX, minY = _a.minY, maxX = _a.maxX, maxY = _a.maxY;
            var oldAvailability = _this.lastPanAvailability;
            var currentTranslation = _this.currentContentTransformation.translation;
            var newAvailability = {
                left: currentTranslation.x < maxX,
                right: currentTranslation.x > minX,
                up: currentTranslation.y < maxY,
                down: currentTranslation.y > minY,
            };
            if (oldAvailability &&
                newAvailability.left === oldAvailability.left &&
                newAvailability.right === oldAvailability.right &&
                newAvailability.up === oldAvailability.up &&
                newAvailability.down === oldAvailability.down)
                return; // nothing has changed, no need to update
            _this.lastPanAvailability = newAvailability;
            _this.onPanAvailabilityChanged(newAvailability);
        };
        /**
         * Updates the zoom availability based on the current transformations.
         */
        this.updateZoomAvailability = function () {
            if (!_this.onZoomAvailabilityChanged)
                return; // nobody cares, no need to update
            var oldAvailability = _this.lastZoomAvailability;
            var currentScale = _this.currentContentTransformation.scale;
            var newAvailability = {
                in: currentScale < _this.maxScale,
                out: currentScale > _this.minScale
            };
            if (oldAvailability &&
                newAvailability.in === oldAvailability.in &&
                newAvailability.out === oldAvailability.out)
                return; // nothing has changed, no need to update
            _this.lastZoomAvailability = newAvailability;
            _this.onZoomAvailabilityChanged(newAvailability);
        };
        /**
         * Adds the required event listeners to the viewport and document.
         */
        this.setEventListeners = function () {
            _this.viewport.addEventListener('touchstart', _this.touchRecognizer.start);
            _this.viewport.addEventListener('mousedown', _this.mouseRecognizer.down);
            _this.viewport.addEventListener('click', _this.mouseRecognizer.click, true);
            _this.viewport.addEventListener('touchmove', _this.touchRecognizer.move);
            // These need to target the whole document to allow panning to extend past the viewport.
            document.addEventListener('touchend', _this.handleTouchEnd);
            document.addEventListener('touchcancel', _this.handleTouchEnd);
            document.addEventListener('mouseup', _this.handleMouseUp);
            document.addEventListener('mousemove', _this.mouseRecognizer.move);
            // We need to listen to resize events to update the viewport size.
            window.addEventListener('resize', _this.handleResize);
        };
        /**
         * Removes the event listeners added by setEventListeners
         */
        this.removeEventListeners = function () {
            if (_this.viewport) {
                _this.viewport.removeEventListener('touchstart', _this.touchRecognizer.start);
                _this.viewport.removeEventListener('mousedown', _this.mouseRecognizer.down);
                _this.viewport.removeEventListener('click', _this.mouseRecognizer.click, true);
                _this.viewport.removeEventListener('touchmove', _this.touchRecognizer.move);
            }
            document.removeEventListener('touchend', _this.handleTouchEnd);
            document.removeEventListener('touchcancel', _this.handleTouchEnd);
            document.removeEventListener('mouseup', _this.handleMouseUp);
            document.removeEventListener('mousemove', _this.mouseRecognizer.move);
            window.removeEventListener('resize', _this.handleResize);
        };
        /**
         * Common handler for end events.
         */
        this.handleEndEvent = function () {
            if (_this.currentContentTransformation.deltaScale !== 1) {
                _this.applyContentTransformation({
                    translation: _this.currentContentTransformation.translation,
                    scale: _this.getCurrentTotalScale()
                }, false);
            }
        };
        /**
         * Handler for touchend events.
         */
        this.handleTouchEnd = function (event) {
            _this.handleEndEvent();
            if (event.target && _this.content.contains(event.target)) {
                _this.touchRecognizer.end(event);
            }
        };
        /**
         * Handler for mouseup events.
         */
        this.handleMouseUp = function (event) {
            _this.handleEndEvent();
            _this.mouseRecognizer.up(event);
        };
        /**
         * Handler for tap events.
         */
        this.handleTap = function (point, target) {
            var shouldTapToZoom = _this.currentContentTransformation.scale === _this.minScale &&
                _this.currentContentTransformation.scale < _this.tapToZoomScaleThreshold;
            if (shouldTapToZoom) {
                // Zoom in to the maximum scale at the point that was tapped.
                var relativeTapPoint = getRelativePoint(point, _this.viewport);
                _this.animateContentTransformation(_this.getZoomTransform(_this.maxScale / _this.minScale, relativeTapPoint));
            }
            else {
                // Otherwise, dispatch a click event to replace the one that was swallowed.
                var evt = new MouseEvent('click', {
                    bubbles: true,
                    cancelable: true,
                    view: window
                });
                if (target)
                    target.dispatchEvent(evt);
            }
        };
        /**
         * Handler for double-tap events.
         */
        this.handleDoubleTap = function (point) {
            var transform = _this.getZoomTransform(_this.zoomIncrement, getRelativePoint(point, _this.viewport));
            _this.animateContentTransformation(transform);
        };
        /**
         * Handler for window resize events.
         */
        this.handleResize = function () {
            var viewportDimensions = _this.getViewportDimensions();
            if (_this.viewportDimensions.width !== viewportDimensions.width ||
                _this.viewportDimensions.height !== viewportDimensions.height) {
                _this.updateViewportSize(viewportDimensions);
                _this.resetZoom();
            }
        };
        /**
         * Updates the viewport size to given dimensions
         */
        this.updateViewportSize = function (viewportDimensions) {
            _this.viewportDimensions = viewportDimensions;
        };
        /**
         * Get the x and y translation of the content when centered within the viewport.
         */
        this.getCenteredContentTranslation = function (scale) {
            var contentDimensions = _this.calculateContentDimensionsAtScale(scale);
            return {
                x: (_this.viewportDimensions.width - contentDimensions.width) / 2,
                y: (_this.viewportDimensions.height - contentDimensions.height) / 2
            };
        };
        /**
         * Gets the centre point of the viewport.
         */
        this.getViewportCenterPoint = function () { return centerPoint(_this.viewportDimensions); };
        this.touchRecognizer.onSingleTap(this.handleTap);
        this.touchRecognizer.onDoubleTap(this.handleDoubleTap);
        this.touchRecognizer.onPinch(this.handlePinch);
        this.touchRecognizer.onPan(this.panBy);
        this.mouseRecognizer.onPan(this.panBy);
    }
    Object.defineProperty(ZoomHandler.prototype, "isAnimating", {
        /**
         * Returns whether or not the content is in the middle of a zoom or pan animation.
         */
        get: function () {
            return !!(this.animator && this.animator.isAnimating);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ZoomHandler.prototype, "isZoomedIn", {
        /**
         * Returns whether or not the content of the viewport is zoomed in.
         */
        get: function () {
            return this.getCurrentTotalScale() > this.minScale;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sets the viewport and content elements, registers event listeners and updates the viewport size.
     */
    ZoomHandler.prototype.setElements = function (viewport, content, contentDimensions) {
        this.viewport = viewport;
        this.content = content;
        this.contentDimensions = contentDimensions;
        this.updateViewportSize(this.getViewportDimensions());
        this.setEventListeners();
        // currentContentTransformation is undefined until resetZoom is initially called, but kept as non-nullable to simplify code
        if (this.currentContentTransformation === undefined) {
            this.resetZoom();
        }
    };
    /**
     * Updates the min scale and centers the content within the viewport.
     */
    ZoomHandler.prototype.resetZoom = function () {
        var _a = this.viewportDimensions, width = _a.width, height = _a.height;
        var minXScale = width / this.contentDimensions.width;
        var minYScale = height / this.contentDimensions.height;
        var minScale = Math.min(minXScale, minYScale, this.maxScale);
        this.minScale = minScale;
        var transformation = {
            scale: minScale,
            translation: this.getCenteredContentTranslation(minScale)
        };
        this.applyContentTransformation(transformation, false);
    };
    /**
     * Removes all event listeners.
     */
    ZoomHandler.prototype.unmount = function () {
        this.removeEventListeners();
    };
    /**
     * Restricts a given scale by the minScale and maxScale values.
     */
    ZoomHandler.prototype.restrictScale = function (scale) {
        return clamp(this.minScale, this.maxScale)(scale);
    };
    /**
     * Gets the current dimensions of the viewport.
     */
    ZoomHandler.prototype.getViewportDimensions = function () {
        return {
            width: this.viewport ? this.viewport.clientWidth : 0,
            height: this.viewport ? this.viewport.clientHeight : 0
        };
    };
    /**
     * Gets the content dimensions relative to a given zoom scale.
     */
    ZoomHandler.prototype.calculateContentDimensionsAtScale = function (scale) {
        return {
            width: this.contentDimensions ? this.contentDimensions.width * scale : 0,
            height: this.contentDimensions ? this.contentDimensions.height * scale : 0
        };
    };
    return ZoomHandler;
}());
export { ZoomHandler };
//# sourceMappingURL=zoom-handler.js.map