import { SeatPickerWidgetScreenPosition, SeatPickerWidgetShape } from '../types/config';
import { getAreaBoundary } from './area';
import { getMapDimension } from './map';
/**
 * Determines whether two row labels will overlap vertically
 * Should only be used when the two row labels are aligned horizontally
 * If the top of one row label is positioned at the bottom of the other, this is not considered overlapping
 */
var rowLabelsOverlapVertically = function (a, b) {
    return a.top < b.top
        ? b.top < a.top + a.height
        : a.top < b.top + b.height;
};
/**
 * Sorts the row labels by the top position, then scans them, filtering out
 * any row labels that overlap with the previous non overlapping label
 */
var getNonOverlappingRowLabels = function (rowLabelProps) {
    var verticallySortedRowLabelProps = rowLabelProps.slice().sort(function (a, b) { return a.top - b.top; });
    var nonOverlappingRowLabelProps = [];
    for (var _i = 0, verticallySortedRowLabelProps_1 = verticallySortedRowLabelProps; _i < verticallySortedRowLabelProps_1.length; _i++) {
        var curr = verticallySortedRowLabelProps_1[_i];
        var last = nonOverlappingRowLabelProps.length === 0
            ? undefined
            : nonOverlappingRowLabelProps[nonOverlappingRowLabelProps.length - 1];
        if (last === undefined || !rowLabelsOverlapVertically(last, curr)) {
            nonOverlappingRowLabelProps.push(curr);
        }
    }
    return nonOverlappingRowLabelProps;
};
/**
 * Returns row label props for each row in each area in SVG units.
 */
export function getRowLabelProps(seatLayout, scaleFactor, config, mapBoundary) {
    var seatMargin = config.seats.margin;
    var _a = config.rowLabels, size = _a.size, shape = _a.shape, borderRadius = _a.borderRadius, borderWidth = _a.borderWidth;
    var parsedBorderRadius = shape === SeatPickerWidgetShape.Round ? size / 2 : borderRadius;
    var rowLabelProps = [];
    var invertSeatMap = config.screen.position === SeatPickerWidgetScreenPosition.Top;
    seatLayout.areas.forEach(function (area) {
        var areaBoundary = getAreaBoundary(area, mapBoundary, scaleFactor, config);
        area.rows.forEach(function (row) {
            if (!row.seats.length)
                return;
            var rowHeightPercentage = area.height / area.rowCount;
            var rowHeight = getMapDimension(rowHeightPercentage, scaleFactor) - (seatMargin * 2);
            var position = row.seats[0].position;
            var rowIndex = invertSeatMap ? area.rowCount - position.rowIndex - 1 : position.rowIndex;
            var rowOffsetPercentage = rowIndex / area.rowCount * area.height;
            var rowAlignmentOffset = (rowHeight - size) / 2;
            var topOffset = getMapDimension(rowOffsetPercentage, scaleFactor) + rowAlignmentOffset + seatMargin;
            rowLabelProps.push({
                top: areaBoundary.top + topOffset,
                left: config.rowLabels.margin,
                width: size,
                height: size,
                label: row.rowLabel,
                borderRadius: parsedBorderRadius,
                borderWidth: borderWidth
            });
        });
    });
    return getNonOverlappingRowLabels(rowLabelProps);
}
//# sourceMappingURL=row-labels.js.map