/**
 * Animation helper that creates animation frames for a given duration to aid in animating from one state to another.
 */
var Animator = /** @class */ (function () {
    /**
     * Creates an animator instance.
     * @param startState The initial state of the animation.
     * @param endState The final state of the animation.
     * @param duration The duration of the animation.
     * @param onAnimationFrameCallback The callback function to be called on each animation frame.
     */
    function Animator(startState, endState, duration, onAnimationFrameCallback) {
        var _this = this;
        this.startState = startState;
        this.endState = endState;
        this.duration = duration;
        this.onAnimationFrameCallback = onAnimationFrameCallback;
        /**
         * Determines whether or not the animation has been cancelled.
         */
        this.isCancelled = false;
        /**
         * Creates an animation frame and repeats in a loop until the animation is complete or cancelled.
         */
        this.animate = function () {
            _this.onAnimationFrameCallback({
                progress: _this.currentProgress,
                isFinalFrame: _this.animationEnded,
                startState: _this.startState,
                endState: _this.endState
            });
            if (_this.isAnimating) {
                _this.animationFrameRequestId = requestAnimationFrame(_this.animate);
            }
        };
    }
    Object.defineProperty(Animator.prototype, "isAnimating", {
        /**
         * Determines whether or not the animation is in progress.
         */
        get: function () {
            return this.startTime !== undefined && !this.isCancelled && !this.animationEnded;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Starts the animation.
     */
    Animator.prototype.start = function () {
        this.cancelAnimationFrameRequest();
        var currentTime = this.currentTime;
        this.startTime = currentTime;
        this.endTime = currentTime + this.duration;
        this.isCancelled = false;
        this.animationFrameRequestId = requestAnimationFrame(this.animate);
    };
    /**
     * Cancels the animation.
     */
    Animator.prototype.cancel = function () {
        this.cancelAnimationFrameRequest();
        this.isCancelled = true;
    };
    /**
     * Cancels the current animation frame request.
     */
    Animator.prototype.cancelAnimationFrameRequest = function () {
        if (this.animationFrameRequestId) {
            cancelAnimationFrame(this.animationFrameRequestId);
        }
    };
    Object.defineProperty(Animator.prototype, "currentTime", {
        /**
         * Gets the current time in milliseconds.
         */
        get: function () {
            return new Date().getTime();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Animator.prototype, "currentProgress", {
        /**
         * Gets the current progress as a number between 0 and 1.
         */
        get: function () {
            if (this.startTime === undefined || this.endTime === undefined)
                return 0;
            return Math.min((this.currentTime - this.startTime) / (this.endTime - this.startTime), 1);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Animator.prototype, "animationEnded", {
        /**
         * Determines whether or not the animation has ended based on the current time.
         */
        get: function () {
            if (this.endTime === undefined)
                return true;
            return this.currentTime >= this.endTime;
        },
        enumerable: true,
        configurable: true
    });
    return Animator;
}());
export { Animator };
export function easeInOutSine(progress, initialValue, finalValue) {
    return (initialValue - finalValue) / 2 * (Math.cos(Math.PI * progress) - 1) + initialValue;
}
//# sourceMappingURL=animator.js.map