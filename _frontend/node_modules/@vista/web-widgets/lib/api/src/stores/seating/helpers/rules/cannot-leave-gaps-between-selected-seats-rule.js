var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import { Direction, getSeatTwoSpacesAway, seatOneSpaceAwayIsAvailable, getSeatsUntil } from '../utils/seat-gap-utils';
import { seatIsCurrentlySelected } from '../utils/seat-layout-state-utils';
import { SeatSelectionRuleName } from './seat-selection-rule';
var defaultOptions = {
    allowGapsWithMultipleSeatsBetweenSelectedSeats: false
};
/**
 * Validates if the selected seats contain a single seat gap
 * between any contiguously selected seats.
 */
export var cannotLeaveGapsBetweenSelectedSeatsRule = function (customOptions) {
    var options = customOptions
        ? __assign({}, defaultOptions, customOptions) : defaultOptions;
    return {
        name: SeatSelectionRuleName.CannotLeaveGapsBetweenSelectedSeats,
        preventSeatSelection: false,
        validate: function (seatLayoutStateManager) {
            var selectedSeats = seatLayoutStateManager.getSelectedSeats();
            var hasInvalidSeats = selectedSeats
                .map(function (seat) { return isSeatValid(seat, seatLayoutStateManager.seatLayout, options); })
                .some(function (x) { return !x; });
            return {
                ruleName: this.name,
                valid: !hasInvalidSeats
            };
        }
    };
};
function isSeatValid(seat, seatLayout, options) {
    if (options.allowGapsWithMultipleSeatsBetweenSelectedSeats) {
        var hasLeftSingleSeatGap = seatOneSpaceAwayIsAvailable(seat, seatLayout, Direction.Left)
            && seatTwoSpacesAwayIsSelected(seat, seatLayout, Direction.Left);
        var hasRightSingleSeatGap = seatOneSpaceAwayIsAvailable(seat, seatLayout, Direction.Right)
            && seatTwoSpacesAwayIsSelected(seat, seatLayout, Direction.Right);
        return !hasLeftSingleSeatGap && !hasRightSingleSeatGap;
    }
    else {
        var hasLeftGap = seatOneSpaceAwayIsAvailable(seat, seatLayout, Direction.Left)
            && anySeatsUntilAisleAreSelected(seat, seatLayout, Direction.Left);
        var hasRightGap = seatOneSpaceAwayIsAvailable(seat, seatLayout, Direction.Right)
            && anySeatsUntilAisleAreSelected(seat, seatLayout, Direction.Right);
        return !hasLeftGap && !hasRightGap;
    }
}
function seatTwoSpacesAwayIsSelected(seat, seatLayout, direction) {
    var seatTwoSpacesAway = getSeatTwoSpacesAway(seat, seatLayout, direction);
    return !!(seatTwoSpacesAway && seatIsCurrentlySelected(seatTwoSpacesAway));
}
function anySeatsUntilAisleAreSelected(seat, seatLayout, direction) {
    var seatsUntilAisle = getSeatsUntil(seat, seatLayout, direction, function (seat) { return seat === undefined; });
    return seatsUntilAisle.some(function (seat) { return seatIsCurrentlySelected(seat); });
}
//# sourceMappingURL=cannot-leave-gaps-between-selected-seats-rule.js.map