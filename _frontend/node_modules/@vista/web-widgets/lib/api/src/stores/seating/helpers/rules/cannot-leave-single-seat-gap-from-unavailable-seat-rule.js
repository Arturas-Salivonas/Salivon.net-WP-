var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import { SeatType } from '../../../../../../types/seating/seat-type';
import { contiguousSeatBlockHasSingleAvailableSeat, Direction, getSeatTwoSpacesAway, seatOneSpaceAwayIsAvailable, contiguousSeatSubBlockHasSingleAvailableSeat } from '../utils/seat-gap-utils';
import { isSofaSeat, seatIsUnavailable } from '../utils/seat-utils';
import { SeatSelectionRuleName } from './seat-selection-rule';
var defaultOptions = {
    ignoreSelectedWheelchairSeats: true,
    ignoreSelectedSofaSeats: true,
    allowWhenAllSeatsBetweenTheSeatGapAndAnUnavailableSeatAreSelected: true
};
/**
 * Validates if the selected seats contain a single seat gap
 * from any unavailable seats e.g. seats that have been previously sold
 */
export var cannotLeaveSingleSeatGapFromUnavailableSeatRule = function (customOptions) {
    var options = customOptions
        ? __assign({}, defaultOptions, customOptions) : defaultOptions;
    return {
        name: SeatSelectionRuleName.CannotLeaveSingleSeatGapFromUnavailableSeat,
        preventSeatSelection: false,
        validate: function (seatLayoutState) {
            var selectedSeats = seatLayoutState.getSelectedSeats();
            var hasInvalidSeats = selectedSeats
                .map(function (seat) { return isSeatValid(seat, seatLayoutState.seatLayout, options); })
                .some(function (x) { return !x; });
            return {
                ruleName: this.name,
                valid: !hasInvalidSeats
            };
        }
    };
};
function isSeatValid(seat, seatLayout, options) {
    if (options.ignoreSelectedWheelchairSeats && seat.type === SeatType.Wheelchair)
        return true;
    if (options.ignoreSelectedSofaSeats && isSofaSeat(seat))
        return true;
    var hasLeftAvailableSeatGapViolation = seatOneSpaceAwayIsAvailable(seat, seatLayout, Direction.Left)
        && seatTwoSpacesAwayIsUnavailable(seat, seatLayout, Direction.Left);
    var hasRightAvailableSeatGapViolation = seatOneSpaceAwayIsAvailable(seat, seatLayout, Direction.Right)
        && seatTwoSpacesAwayIsUnavailable(seat, seatLayout, Direction.Right);
    var hasAvailableSeatGapViolation = (!hasLeftAvailableSeatGapViolation && !hasRightAvailableSeatGapViolation)
        || contiguousSeatBlockHasSingleAvailableSeat(seat, seatLayout);
    if (options.allowWhenAllSeatsBetweenTheSeatGapAndAnUnavailableSeatAreSelected) {
        return hasAvailableSeatGapViolation || contiguousSeatSubBlockHasSingleAvailableSeat(seat, seatLayout);
    }
    else {
        return hasAvailableSeatGapViolation;
    }
}
function seatTwoSpacesAwayIsUnavailable(seat, seatLayout, direction) {
    var seatTwoSpacesAway = getSeatTwoSpacesAway(seat, seatLayout, direction);
    return !!(seatTwoSpacesAway && seatIsUnavailable(seatTwoSpacesAway));
}
//# sourceMappingURL=cannot-leave-single-seat-gap-from-unavailable-seat-rule.js.map