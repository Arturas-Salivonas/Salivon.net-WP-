var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import { SeatType } from '../../../../../../types/seating/seat-type';
import { contiguousSeatBlockHasSingleAvailableSeat, Direction, getSeatsUntil, getSeatTwoSpacesAway, seatOneSpaceAwayIsAvailable } from '../utils/seat-gap-utils';
import { seatIsCurrentlySelected } from '../utils/seat-layout-state-utils';
import { isSofaSeat, seatIsUnavailable } from '../utils/seat-utils';
import { SeatSelectionRuleName } from './seat-selection-rule';
var defaultOptions = {
    ignoreSelectedWheelchairSeats: true,
    ignoreSelectedSofaSeats: true,
    allowWhenAllSeatsBetweenTheSeatGapAndAnUnavailableSeatAreSelected: true
};
/**
 * Creates a SeatSelectionRule that validates if the selected seats contain a single seat gap from an aisle
 * The rule does not fail when the seat gap is the last remaining seat in the contiguous block
 */
export var cannotLeaveSingleSeatGapFromAisleRule = function (customOptions) {
    var options = customOptions
        ? __assign({}, defaultOptions, customOptions) : defaultOptions;
    return {
        name: SeatSelectionRuleName.CannotLeaveSingleSeatGapFromAisle,
        preventSeatSelection: false,
        validate: function (seatLayoutState) {
            var selectedSeats = seatLayoutState.getSelectedSeats();
            var hasInvalidSeats = selectedSeats
                .map(function (seat) { return isSeatValid(seat, seatLayoutState.seatLayout, options); })
                .some(function (x) { return !x; });
            return {
                ruleName: this.name,
                valid: !hasInvalidSeats
            };
        }
    };
};
function isSeatValid(seat, seatLayout, options) {
    if (options.ignoreSelectedWheelchairSeats && seat.type === SeatType.Wheelchair)
        return true;
    if (options.ignoreSelectedSofaSeats && isSofaSeat(seat))
        return true;
    var leftAisleValid = !hasAvailableSeatGapFromAisle(seat, seatLayout, Direction.Left)
        || (options.allowWhenAllSeatsBetweenTheSeatGapAndAnUnavailableSeatAreSelected && allSeatsBetweenSeatAndNextUnavailableSeatAreSelected(seat, seatLayout, Direction.Right));
    var rightAisleValid = !hasAvailableSeatGapFromAisle(seat, seatLayout, Direction.Right)
        || (options.allowWhenAllSeatsBetweenTheSeatGapAndAnUnavailableSeatAreSelected && allSeatsBetweenSeatAndNextUnavailableSeatAreSelected(seat, seatLayout, Direction.Left));
    return (leftAisleValid && rightAisleValid) || contiguousSeatBlockHasSingleAvailableSeat(seat, seatLayout);
}
function hasAvailableSeatGapFromAisle(seat, seatLayout, direction) {
    return seatOneSpaceAwayIsAvailable(seat, seatLayout, direction) && seatTwoSpacesAwayIsAisle(seat, seatLayout, direction);
}
function allSeatsBetweenSeatAndNextUnavailableSeatAreSelected(seat, seatLayout, direction) {
    var seatsUntilUnavailableSeat = getSeatsUntil(seat, seatLayout, direction, function (seat) { return !!(seat && seatIsUnavailable(seat)); });
    return seatsUntilUnavailableSeat.every(function (seat) { return seatIsCurrentlySelected(seat); });
}
function seatTwoSpacesAwayIsAisle(seat, seatLayout, direction) {
    var seatTwoSpacesAway = getSeatTwoSpacesAway(seat, seatLayout, direction);
    return seatTwoSpacesAway === undefined;
}
//# sourceMappingURL=cannot-leave-single-seat-gap-from-aisle-rule.js.map