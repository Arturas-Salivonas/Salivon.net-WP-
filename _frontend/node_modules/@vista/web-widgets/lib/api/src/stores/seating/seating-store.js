var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { action, computed, extendObservable, reaction, toJS } from 'mobx';
import { SeatAvailability } from '../../../../types/seating/seat-availability';
import { getAreaCategoryForSeat } from '../../mappers/seating/seat-layout-mapper';
import { browserSessionServiceInstance } from '../../user/browser-session-service';
import { cacheServiceInstance } from '../../user/cache-service';
import { Logger } from '../../utils/logger';
import { ConfigurableBaseStore } from '../configurable-base-store';
import { configurationStoreInstance } from '../configuration/configuration-store';
import { PopFirstSelectedSeatHandler } from '../seating/helpers/handlers/pop-first-selected-seat-handler';
import { SeatingErrorCategory } from '../seating/helpers/types';
import { getSeatLayoutAutoAllocationStatus } from '../seating/helpers/utils/seat-layout-utils';
import { getSelectedSeats, seatSelectionsAreEqual } from '../seating/helpers/utils/seat-selection-utils';
import { getSeatByPosition } from '../seating/helpers/utils/seat-utils';
import { defaultSeatSelectionRules } from './helpers/rules/rules';
/**
 * Seating Store class
 */
var SeatingStore = /** @class */ (function (_super) {
    __extends(SeatingStore, _super);
    function SeatingStore(defaultOptions) {
        var _this = 
        // call BaseStore constructor with no defaults
        _super.call(this, 'seating-store', browserSessionServiceInstance, cacheServiceInstance, undefined, defaultOptions) || this;
        /**
         * Returns whether the current seat selection is valid or not.
         * Should be called prior to saving the seats in the backend.
         */
        _this.validateSelection = function () {
            var selectionWasAutoAllocated = _this.data.seatLayoutAutoAllocationStatus.autoAllocated
                && seatSelectionsAreEqual(_this.selectedSeats.map(function (s) { return s.position; }), _this.data.seatLayoutAutoAllocationStatus.seatPositions);
            if (selectionWasAutoAllocated) {
                _this.setErrorMessages([]);
                return true;
            }
            var validationResult = _this.options.selectSeatHandler.validateSelection();
            var errors = validationResult.ruleViolations.map(function (v) { return ({
                category: SeatingErrorCategory.RuleViolation,
                ruleName: v.ruleName
            }); });
            _this.setErrorMessages(errors);
            return validationResult.valid;
        };
        /**
         * Clear all validation error messages
         */
        _this.clearErrorMessages = function () {
            _this.setData({ errors: [] });
        };
        // bind action to store instance
        _this.seatClicked = _this.seatClicked.bind(_this);
        return _this;
    }
    /**
     * Sets the store data and updates the seat layout data of the select seat handler
     *
     * @param {SeatingStoreData} data Data to set
     */
    SeatingStore.prototype.setData = function (data) {
        // TODO: When seat first ordering is on, autoAllocated should always be false
        if (data.seatLayout)
            data.seatLayoutAutoAllocationStatus = getSeatLayoutAutoAllocationStatus(data.seatLayout);
        _super.prototype.setData.call(this, data);
        if (this.data.seatLayout && this.data.friendSeats) {
            this.updateSeatLayoutWithFriendSeats(this.data.seatLayout, this.data.friendSeats);
        }
        if (data.hasOwnProperty('seatLayout')) {
            this.options.selectSeatHandler.setSeatLayout(this.data.seatLayout);
        }
    };
    /**
     * Sets the seat layout data
     * @param data The seat layout data
     */
    SeatingStore.prototype.setSeatLayout = function (seatLayout) {
        this.setData({ seatLayout: seatLayout, errors: [] });
    };
    /**
     * Sets the seating options
     * @param options the options to use for seating
     */
    SeatingStore.prototype.setOptions = function (options) {
        _super.prototype.setOptions.call(this, options);
        this.options.selectSeatHandler.setSeatLayout(this.data.seatLayout);
    };
    /**
     * provide callback to trigger when selected seats changed
     *
     * Example:
     * ```
     * const disposer = seatingStore.onSelectedSeatsChanged((selectedSeats) => { })
     * // will console log selected seats data
     * disposer();
     * // will unsubscribe from being notified when the seat collection changes
     * ```
     * @param callback
     */
    SeatingStore.prototype.onSelectedSeatsChanged = function (callback) {
        var _this = this;
        return reaction(function () { return _this.selectedSeats; }, function (selectedSeatObservables) {
            var selectedSeats = selectedSeatObservables.map(function (x) { return toJS(x); });
            callback(selectedSeats);
        });
    };
    /**
     * Responds to a seat clicked events.
     * @param {Seat} seat
     */
    SeatingStore.prototype.seatClicked = function (seat) {
        // Cannot perform a seat selection action without a handler.
        if (!this.options.selectSeatHandler) {
            Logger.warn('No seat selection handler available, impossible to perform selection.');
            return;
        }
        if (seat.availability === SeatAvailability.Available)
            this.selectSeat(seat);
        else if (seat.availability === SeatAvailability.Selected)
            this.deselectSeat(seat);
        else
            Logger.warn('Cannot select or deselect a sold seat');
        this.syncToCache(); // persit the state to session storage.
    };
    /**
     * Selects a given seat within the seat layout.
     * @param seat the seat to be selected.
     */
    SeatingStore.prototype.selectSeat = function (seat) {
        var areaCategory = getAreaCategoryForSeat(seat, this.data.seatLayout);
        var selectionResult = this.options.selectSeatHandler.selectSeat(seat, areaCategory);
        if (!selectionResult.valid) {
            Logger.warn('Provided seat cannot be selected', { seat: seat, violations: selectionResult.ruleViolations });
        }
    };
    /**
     * Deselects a given seat within the seat layout.
     * @param seat the seat to be deselected.
     */
    SeatingStore.prototype.deselectSeat = function (seat) {
        var areaCategory = getAreaCategoryForSeat(seat, this.data.seatLayout);
        this.options.selectSeatHandler.deselectSeat(seat, areaCategory);
    };
    /**
     * Set validation error messages
     */
    SeatingStore.prototype.setErrorMessages = function (errorMessages) {
        this.setData({ errors: errorMessages });
    };
    Object.defineProperty(SeatingStore.prototype, "hasSeatLayoutData", {
        /**
         * Returns true if seat layout data exists
         */
        get: function () {
            return !!this.data.seatLayout && !!this.data.seatLayout.areas;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SeatingStore.prototype, "selectedSeats", {
        /**
         * Returns the currently selected seats.
         * @returns {Seat[]}
         */
        get: function () {
            if (!this.data.seatLayout || !this.data.seatLayout.areaCategories)
                return [];
            return toJS(getSelectedSeats(this.data.seatLayout));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sets the selected seats to an array of given seat positions.
     * @param seatPositions the positions of the new selected seats.
     */
    SeatingStore.prototype.setSelectedSeats = function (seatPositions) {
        var _this = this;
        // Find new seats by their positions
        var seats = seatPositions.map(function (position) {
            var seat = getSeatByPosition(_this.data.seatLayout, position);
            // Validate that the seats exists
            if (!seat)
                throw new Error("Seat at position " + JSON.stringify(position) + " does not exist");
            // Validate that the seat is available
            if (seat.availability === SeatAvailability.Sold)
                throw new Error("Cannot select sold seat at position " + JSON.stringify(position));
            return seat;
        });
        // Deselect all currently selected seats
        this.selectedSeats.forEach(function (seat) { return _this.deselectSeat(seat); });
        // Select each of the new seats
        seats.forEach(function (seat) { return _this.selectSeat(seat); });
        this.syncToCache();
    };
    SeatingStore.prototype.updateSeatLayoutWithFriendSeats = function (seatLayout, friendSeats) {
        friendSeats.forEach(function (friendPosition) {
            var seat = getSeatByPosition(seatLayout, friendPosition);
            if (seat !== undefined) {
                if (seat.availability === SeatAvailability.Sold) {
                    extendObservable(seat, { isFriendSeat: true });
                }
                else {
                    Logger.warn("Seat " + JSON.stringify(friendPosition) + " is not sold so cannot be set as a friend seat");
                }
            }
            else {
                Logger.warn("Seat " + JSON.stringify(friendPosition) + " was not found so cannot be set as a friend seat");
            }
        });
    };
    __decorate([
        action,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", void 0)
    ], SeatingStore.prototype, "setData", null);
    __decorate([
        action,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", void 0)
    ], SeatingStore.prototype, "setSeatLayout", null);
    __decorate([
        action,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", void 0)
    ], SeatingStore.prototype, "seatClicked", null);
    __decorate([
        action,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", void 0)
    ], SeatingStore.prototype, "selectSeat", null);
    __decorate([
        action,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", void 0)
    ], SeatingStore.prototype, "deselectSeat", null);
    __decorate([
        action,
        __metadata("design:type", Object)
    ], SeatingStore.prototype, "validateSelection", void 0);
    __decorate([
        action,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Array]),
        __metadata("design:returntype", void 0)
    ], SeatingStore.prototype, "setErrorMessages", null);
    __decorate([
        action,
        __metadata("design:type", Object)
    ], SeatingStore.prototype, "clearErrorMessages", void 0);
    __decorate([
        computed,
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], SeatingStore.prototype, "hasSeatLayoutData", null);
    __decorate([
        computed,
        __metadata("design:type", Array),
        __metadata("design:paramtypes", [])
    ], SeatingStore.prototype, "selectedSeats", null);
    __decorate([
        action,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Array]),
        __metadata("design:returntype", void 0)
    ], SeatingStore.prototype, "setSelectedSeats", null);
    return SeatingStore;
}(ConfigurableBaseStore));
export { SeatingStore };
// create default store instance
var defaultOptions = {
    selectSeatHandler: new PopFirstSelectedSeatHandler(defaultSeatSelectionRules, configurationStoreInstance.data.ticketing.isSeatFirstOrdering, configurationStoreInstance.data.ticketing.maximumAllowedTicketsInAnOrder)
};
export var seatingStoreInstance = new SeatingStore(defaultOptions);
//# sourceMappingURL=seating-store.js.map