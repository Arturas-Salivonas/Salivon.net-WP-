import { Logger } from '../../../../utils/logger';
import { SeatLayoutStateManager } from '../utils/seat-layout-state-manager';
import { SeatFirstSelectedSeatsQueueManager } from './seat-first-selected-seats-queue-manager';
import { TicketFirstSelectedSeatsQueueManager } from './ticket-first-selected-seats-queue-manager';
/**
 * Allows the user to select new seats without having to manually deselect any currently selected seats.
 * If all seats have been selected, this handler will automatically deselect the first selected seat
 * before selecting the new seat.
 *
 * @export
 * @class PopFirstSelectedSeatHandler
 * @implements {SeatSelectionHandler}
 */
var PopFirstSelectedSeatHandler = /** @class */ (function () {
    function PopFirstSelectedSeatHandler(rules, isSeatFirstOrdering, maximumTicketsAllowedInAnOrder) {
        this.rules = rules;
        this.isSeatFirstOrdering = isSeatFirstOrdering;
        this.maximumTicketsAllowedInAnOrder = maximumTicketsAllowedInAnOrder;
    }
    /**
     * Sets the seat layout to use.
     */
    PopFirstSelectedSeatHandler.prototype.setSeatLayout = function (seatLayout) {
        this.seatLayoutStateManager = new SeatLayoutStateManager(seatLayout, this.isSeatFirstOrdering, this.maximumTicketsAllowedInAnOrder);
        this.selectedSeatsQueueManager = this.isSeatFirstOrdering
            ? new SeatFirstSelectedSeatsQueueManager(seatLayout)
            : new TicketFirstSelectedSeatsQueueManager(seatLayout);
    };
    /**
     * Selects a seat within the seat layout.
     *
     * If the seat selection is valid, this function will update the seat layout directly and return true.
     * Otherwise, this function will return a list of seat selection rules that have been violated.
     * @param seat The seat to be selected.
     */
    PopFirstSelectedSeatHandler.prototype.selectSeat = function (seat) {
        Logger.info('selecting seat', { seat: seat });
        // If all seats have been allocated for this seats area category or max seats have been reached, 'pop' the first selected seat.
        if (!this.seatLayoutStateManager.canAllocateSeat(seat)) {
            var seatToDeselect = this.selectedSeatsQueueManager.popSeatToAccomodateNewSeat(seat);
            if (seatToDeselect) {
                this.seatLayoutStateManager.deselectSeat(seatToDeselect);
            }
        }
        // Select the seat
        this.seatLayoutStateManager.selectSeat(seat);
        this.selectedSeatsQueueManager.selectSeat(seat);
        // Validate the selection
        var validationResult = this.getSeatSelectionValidationResult();
        if (!validationResult.valid) {
            Logger.info('invalid seat selection', validationResult);
            this.seatLayoutStateManager.discardStateChanges();
            this.selectedSeatsQueueManager.discardChanges();
        }
        else {
            this.seatLayoutStateManager.applyStateChanges();
            this.selectedSeatsQueueManager.saveChanges();
        }
        return validationResult;
    };
    /**
     * Deselects a seat within the seat layout.
     * @param seat The seat to be deselected.
     */
    PopFirstSelectedSeatHandler.prototype.deselectSeat = function (seat, areaCategory) {
        Logger.info('deselectSeat', seat);
        this.selectedSeatsQueueManager.deselectSeat(seat);
        this.seatLayoutStateManager.deselectSeat(seat);
        this.seatLayoutStateManager.applyStateChanges();
        this.selectedSeatsQueueManager.saveChanges();
    };
    /**
     * Validates the current seat selections against all seating rules.
     * @returns {SeatSelectionValidationResult}
     */
    PopFirstSelectedSeatHandler.prototype.validateSelection = function () {
        var _this = this;
        var ruleViolations = this.rules
            .map(function (r) { return r.validate(_this.seatLayoutStateManager); })
            .filter(function (vr) { return vr.valid !== true; });
        return {
            valid: !ruleViolations.length,
            ruleViolations: ruleViolations
        };
    };
    /**
     * Validates a seat selection against the rules that prevent a seat selection when violated.
     * @private
     * @returns {SeatSelectionValidationResult}
     */
    PopFirstSelectedSeatHandler.prototype.getSeatSelectionValidationResult = function () {
        var _this = this;
        var ruleViolations = this.rules
            .filter(function (r) { return r.preventSeatSelection; })
            .map(function (r) { return r.validate(_this.seatLayoutStateManager); })
            .filter(function (vr) { return vr.valid !== true; });
        return {
            valid: !ruleViolations.length,
            ruleViolations: ruleViolations
        };
    };
    return PopFirstSelectedSeatHandler;
}());
export { PopFirstSelectedSeatHandler };
//# sourceMappingURL=pop-first-selected-seat-handler.js.map