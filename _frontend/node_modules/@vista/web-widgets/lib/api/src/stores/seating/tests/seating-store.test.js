var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import { toJS } from 'mobx';
import { SeatAvailability } from '../../../../../types/seating/seat-availability';
import { Logger } from '../../../utils/logger';
import { createSingleRowSeatLayout, getSeat, selectSeat } from '../../seating/helpers/test/test-utils';
import { SeatingErrorCategory } from '../../seating/helpers/types';
import { SeatLayoutStateManager } from '../../seating/helpers/utils/seat-layout-state-manager';
import { SeatSelectionRuleName } from '../helpers/rules/seat-selection-rule';
import { SeatLayoutBuilder } from '../helpers/test/seat-layout-builder';
import { SeatingStore } from '../seating-store';
var spyLoggerWarn = jest.spyOn(Logger, 'warn');
/**
 * @hidden
 */
var MockSeatSelectionHandlerSuccess = /** @class */ (function () {
    function MockSeatSelectionHandlerSuccess() {
        this.setSeatLayout = jest.fn();
        this.selectSeat = jest.fn().mockReturnValue({ success: true });
        this.deselectSeat = jest.fn();
    }
    return MockSeatSelectionHandlerSuccess;
}());
/**
 * @hidden
 */
var MockSeatSelectionHandlerViolation = /** @class */ (function () {
    function MockSeatSelectionHandlerViolation() {
        this.setSeatLayout = jest.fn();
        this.selectSeat = jest.fn().mockReturnValue({ valid: false, ruleViolations: 'ouch!' });
    }
    return MockSeatSelectionHandlerViolation;
}());
/**
 * Seating Store class test
 */
describe('Seating Store', function () {
    var seatingStore;
    var testSeatLayout;
    var testAreaCategory;
    var testAvailableSeat;
    var testSoldSeat;
    var testSelectedSeat;
    beforeEach(function () {
        spyLoggerWarn.mockClear();
        testSeatLayout = new SeatLayoutBuilder().addAreaCategory(function (areaCat) {
            return areaCat.addArea(function (area) {
                area.addRow('A', function (row) {
                    row.addSeat({ availability: SeatAvailability.Available });
                    row.addSeat({ availability: SeatAvailability.Sold });
                    row.addSeat({ availability: SeatAvailability.Selected });
                });
            });
        }).create();
        testAreaCategory = testSeatLayout.areaCategories[0];
        testAvailableSeat = testSeatLayout.areas[0].rows[0].seats[0];
        testSoldSeat = testSeatLayout.areas[0].rows[0].seats[1];
        testSelectedSeat = testSeatLayout.areas[0].rows[0].seats[2];
    });
    describe('constructor', function () {
        it('doesn\'t have default data', function () {
            seatingStore = new SeatingStore();
            expect(toJS(seatingStore.data)).toEqual({});
        });
    });
    describe('setData', function () {
        it('sets the seat selection handler data', function () {
            var handler = new MockSeatSelectionHandlerViolation();
            seatingStore = new SeatingStore({ selectSeatHandler: handler });
            var seatData = { seatLayout: {} };
            seatingStore.setData(seatData);
            expect(handler.setSeatLayout).toBeCalledWith({});
        });
        it('sets the seat layout auto allocation status when seat layout is set', function () {
            var handler = new MockSeatSelectionHandlerViolation();
            seatingStore = new SeatingStore({ selectSeatHandler: handler });
            var seatData = { seatLayout: testSeatLayout };
            seatingStore.setData(seatData);
            var expected = {
                autoAllocated: true,
                seatPositions: [testSelectedSeat.position]
            };
            expect(toJS(seatingStore.data.seatLayoutAutoAllocationStatus)).toEqual(expected);
        });
        it('updates seat layout with friends seats', function () {
            var seatLayout = createSingleRowSeatLayout(function (row) { return row
                .addSeat({ availability: SeatAvailability.Sold, seatLabel: '1' })
                .addSeat({ availability: SeatAvailability.Sold, seatLabel: '2' }); });
            var friendSeatPosition = getSeat('A', '1', seatLayout).position;
            var handler = new MockSeatSelectionHandlerViolation();
            seatingStore = new SeatingStore({ selectSeatHandler: handler });
            var seatData = {
                seatLayout: seatLayout,
                friendSeats: [friendSeatPosition]
            };
            seatingStore.setData(seatData);
            var friendSeat = getSeat('A', '1', seatingStore.data.seatLayout);
            var normalSeat = getSeat('A', '2', seatingStore.data.seatLayout);
            expect(friendSeat.isFriendSeat).toBe(true);
            expect(normalSeat.isFriendSeat).toBeUndefined();
        });
        it('ignores invalid friend seats and logs a warning', function () {
            var seatLayout = createSingleRowSeatLayout(function (row) { return row
                .addSeat({ availability: SeatAvailability.Available, seatLabel: '1' }); });
            var availableSeat = getSeat('A', '1', seatLayout).position;
            var friendSeatPositions = [
                availableSeat,
                __assign({}, availableSeat, { columnIndex: availableSeat.columnIndex + 1 })
            ];
            var handler = new MockSeatSelectionHandlerViolation();
            seatingStore = new SeatingStore({ selectSeatHandler: handler });
            var seatData = {
                seatLayout: seatLayout,
                friendSeats: friendSeatPositions
            };
            seatingStore.setData(seatData);
            var normalSeat = getSeat('A', '1', seatingStore.data.seatLayout);
            expect(normalSeat.isFriendSeat).toBeUndefined();
            expect(spyLoggerWarn).toMatchSnapshot();
        });
    });
    describe('setSeatLayout', function () {
        it('sets the seat layout data and resets the validation result', function () {
            var handler = new MockSeatSelectionHandlerViolation();
            seatingStore = new SeatingStore({ selectSeatHandler: handler });
            seatingStore.setData = jest.fn();
            var seatLayout = {};
            seatingStore.setSeatLayout(seatLayout);
            expect(seatingStore.setData).toBeCalledWith({ seatLayout: seatLayout, errors: [] });
        });
    });
    describe('setOptions', function () {
        it('sets the seat selection handler data when options are set', function () {
            var handler1 = new MockSeatSelectionHandlerViolation();
            var handler2 = new MockSeatSelectionHandlerViolation();
            seatingStore = new SeatingStore({ selectSeatHandler: handler1 });
            var seatingOptions = {
                selectSeatHandler: handler2
            };
            var seatData = { seatLayout: {} };
            seatingStore.setData(seatData);
            seatingStore.setOptions(seatingOptions);
            expect(handler2.setSeatLayout).toBeCalledWith({});
        });
    });
    describe('seatClicked', function () {
        it('logs a warning when no handler is available', function () {
            seatingStore = new SeatingStore();
            seatingStore.seatClicked({});
            expect(spyLoggerWarn).toBeCalledWith('No seat selection handler available, impossible to perform selection.');
        });
        it('calls selectSeat when the seat is available', function () {
            var handler = new MockSeatSelectionHandlerSuccess();
            seatingStore = new SeatingStore({ selectSeatHandler: handler });
            seatingStore.setData({ seatLayout: testSeatLayout });
            seatingStore.selectSeat = jest.fn();
            seatingStore.seatClicked(testAvailableSeat);
            expect(seatingStore.selectSeat).toBeCalledWith(testAvailableSeat);
        });
        it('calls deselectSeat when the seat is selected', function () {
            var handler = new MockSeatSelectionHandlerSuccess();
            seatingStore = new SeatingStore({ selectSeatHandler: handler });
            seatingStore.setData({ seatLayout: testSeatLayout });
            seatingStore.deselectSeat = jest.fn();
            seatingStore.seatClicked(testSelectedSeat);
            expect(seatingStore.deselectSeat).toBeCalledWith(testSelectedSeat);
        });
        it('logs a warning when the seat is sold', function () {
            var handler = new MockSeatSelectionHandlerSuccess();
            seatingStore = new SeatingStore({ selectSeatHandler: handler });
            seatingStore.setData({ seatLayout: testSeatLayout });
            seatingStore.seatClicked(testSoldSeat);
            expect(spyLoggerWarn).toBeCalledWith('Cannot select or deselect a sold seat');
        });
    });
    describe('selectSeat', function () {
        it('it gets the areaCategory for the seat and provides the seat and areaCategory to the handler', function () {
            var handler = new MockSeatSelectionHandlerSuccess();
            seatingStore = new SeatingStore({ selectSeatHandler: handler });
            seatingStore.setData({ seatLayout: testSeatLayout });
            seatingStore.selectSeat(testAvailableSeat);
            var args = handler.selectSeat.mock.calls[0];
            expect(args[0]).toEqual(testAvailableSeat);
            expect(toJS(args[1])).toEqual(testAreaCategory);
        });
        it('logs a warning when the seat selection was invalid', function () {
            var handler = new MockSeatSelectionHandlerViolation();
            seatingStore = new SeatingStore({ selectSeatHandler: handler });
            seatingStore.setData({ seatLayout: testSeatLayout });
            seatingStore.selectSeat(testAvailableSeat);
            var args = handler.selectSeat.mock.calls[0];
            expect(args[0]).toEqual(testAvailableSeat);
            expect(toJS(args[1])).toEqual(testAreaCategory);
            expect(spyLoggerWarn).toBeCalledWith('Provided seat cannot be selected', { seat: testAvailableSeat, violations: 'ouch!' });
        });
    });
    describe('deselectSeat', function () {
        it('it gets the areaCategory for the seat and provides the seat and areaCategory to the handler', function () {
            var handler = new MockSeatSelectionHandlerSuccess();
            seatingStore = new SeatingStore({ selectSeatHandler: handler });
            seatingStore.setData({ seatLayout: testSeatLayout });
            seatingStore.deselectSeat(testAvailableSeat);
            var args = handler.deselectSeat.mock.calls[0];
            expect(args[0]).toEqual(testAvailableSeat);
            expect(toJS(args[1])).toEqual(testAreaCategory);
        });
    });
    describe('validateSelection', function () {
        var handler;
        beforeEach(function () {
            handler = new MockSeatSelectionHandlerViolation();
            seatingStore = new SeatingStore({ selectSeatHandler: handler });
            seatingStore.setData({ seatLayout: testSeatLayout });
        });
        it('sets the validation result when validateSelection is called', function () {
            var validationResult = { valid: true };
            handler.validateSelection = jest.fn().mockReturnValue(validationResult);
            seatingStore.validateSelection();
            var result = seatingStore.data.errors;
            expect(toJS(result)).toEqual([]);
        });
        it('returns validation result when validateSelection is called', function () {
            var validationResult = { valid: true };
            handler.validateSelection = jest.fn().mockReturnValue(validationResult);
            expect(seatingStore.validateSelection()).toBe(true);
        });
        it('skips validation when selected seats are the same as the auto allocated seats', function () {
            seatingStore.setData({
                seatLayoutAutoAllocationStatus: {
                    autoAllocated: true,
                    seatPositions: [testSelectedSeat.position]
                }
            });
            handler.validateSelection = jest.fn();
            expect(seatingStore.validateSelection()).toBe(true);
            expect(handler.validateSelection).not.toBeCalled();
        });
        it('clears error messages when selected seats are the same as the auto allocated seats', function () {
            seatingStore.setData({
                errors: [{}],
                seatLayoutAutoAllocationStatus: {
                    autoAllocated: true,
                    seatPositions: [testSelectedSeat.position]
                }
            });
            handler.validateSelection = jest.fn();
            expect(seatingStore.validateSelection()).toBe(true);
            expect(handler.validateSelection).not.toBeCalled();
            expect(toJS(seatingStore.data.errors)).toEqual([]);
        });
        it('doesn\'t skip validation when selected seats differ from the auto allocated seats', function () {
            seatingStore.setData({
                seatLayoutAutoAllocationStatus: {
                    autoAllocated: true,
                    seatPositions: []
                }
            });
            var validationResult = { valid: false, ruleViolations: [] };
            handler.validateSelection = jest.fn().mockReturnValue(validationResult);
            expect(seatingStore.validateSelection()).toBe(false);
            expect(handler.validateSelection).toBeCalled();
        });
        it('doesn\'t skip validation when seats were not auto allocated', function () {
            seatingStore.setData({
                seatLayoutAutoAllocationStatus: {
                    autoAllocated: false
                }
            });
            handler.validateSelection = jest.fn().mockReturnValue({ valid: false, ruleViolations: [] });
            expect(seatingStore.validateSelection()).toBe(false);
            expect(handler.validateSelection).toBeCalled();
        });
    });
    describe('selectedSeats', function () {
        it('returns an empty array if the seat layout has not been set', function () {
            var handler = new MockSeatSelectionHandlerSuccess();
            seatingStore = new SeatingStore({ selectSeatHandler: handler });
            expect(seatingStore.selectedSeats).toEqual([]);
        });
        it('can compute selected seats', function () {
            var handler = new MockSeatSelectionHandlerSuccess();
            seatingStore = new SeatingStore({ selectSeatHandler: handler });
            var seatLayout = createSingleRowSeatLayout(function (row) { return row
                .addSeat({ availability: SeatAvailability.Selected, seatLabel: '1' })
                .addSeat({ availability: SeatAvailability.Selected, seatLabel: '2' })
                .addSeat({ availability: SeatAvailability.Sold, seatLabel: '3' })
                .addSeat({ availability: SeatAvailability.Available, seatLabel: '4' }); });
            seatingStore.setSeatLayout(seatLayout);
            var selectedSeats = [getSeat('A', '1', seatLayout), getSeat('A', '2', seatLayout)];
            expect(seatingStore.selectedSeats).toMatchObject(selectedSeats);
        });
    });
    describe('onSelectedSeatsChanged', function () {
        it('can subscribe and unsubscribe to onSelectedSeatsChanged', function () {
            var mockCallback = jest.fn();
            var handler = new MockSeatSelectionHandlerViolation();
            seatingStore = new SeatingStore({ selectSeatHandler: handler });
            var seatLayout = createSingleRowSeatLayout(function (row) { return row
                .addSeat({ availability: SeatAvailability.Available, seatLabel: '1' })
                .addSeat({ availability: SeatAvailability.Available, seatLabel: '2' }); });
            seatingStore.setSeatLayout(seatLayout);
            var seatLayoutStateManager = new SeatLayoutStateManager(seatingStore.data.seatLayout, false, 10);
            var disposer = seatingStore.onSelectedSeatsChanged(mockCallback);
            selectSeat('A', '1', seatLayoutStateManager);
            seatLayoutStateManager.applyStateChanges();
            expect(mockCallback).toHaveBeenCalledTimes(1);
            disposer();
            selectSeat('A', '2', seatLayoutStateManager);
            seatLayoutStateManager.applyStateChanges();
            expect(mockCallback).toHaveBeenCalledTimes(1);
        });
    });
    describe('setSelectedSeats', function () {
        it('throws an error when a provided seat position does not exist in the layout', function () {
            var handler = new MockSeatSelectionHandlerSuccess();
            seatingStore = new SeatingStore({ selectSeatHandler: handler });
            seatingStore.setData({ seatLayout: testSeatLayout });
            var seatPositions = [
                {
                    areaNumber: -1,
                    rowIndex: -1,
                    columnIndex: -1
                }
            ];
            expect(function () { return seatingStore.setSelectedSeats(seatPositions); }).toThrowErrorMatchingSnapshot();
        });
        it('throws an error when a provided seat is sold', function () {
            var handler = new MockSeatSelectionHandlerSuccess();
            seatingStore = new SeatingStore({ selectSeatHandler: handler });
            seatingStore.setData({ seatLayout: testSeatLayout });
            var seatPositions = [
                testSoldSeat.position
            ];
            expect(function () { return seatingStore.setSelectedSeats(seatPositions); }).toThrowErrorMatchingSnapshot();
        });
        it('deselects the previously selected seat and selects the given seat', function () {
            var handler = new MockSeatSelectionHandlerSuccess();
            seatingStore = new SeatingStore({ selectSeatHandler: handler });
            seatingStore.setData({ seatLayout: testSeatLayout });
            var seatPositions = [
                testAvailableSeat.position
            ];
            seatingStore.setSelectedSeats(seatPositions);
            var deselectArgs = handler.deselectSeat.mock.calls[0];
            expect(deselectArgs[0]).toEqual(testSelectedSeat);
            expect(toJS(deselectArgs[1])).toEqual(testAreaCategory);
            var selectArgs = handler.selectSeat.mock.calls[0];
            expect(selectArgs[0]).toEqual(testAvailableSeat);
            expect(toJS(selectArgs[1])).toEqual(testAreaCategory);
        });
    });
    describe('hasSeatLayoutData', function () {
        it('returns true when seat layout exists with areas', function () {
            var handler = new MockSeatSelectionHandlerSuccess();
            var seatingStore = new SeatingStore({ selectSeatHandler: handler });
            var seatLayout = {
                areas: []
            };
            seatingStore.setSeatLayout(seatLayout);
            expect(seatingStore.hasSeatLayoutData).toBe(true);
        });
        it('returns false when seat layout is undefined', function () {
            var handler = new MockSeatSelectionHandlerSuccess();
            var seatingStore = new SeatingStore({ selectSeatHandler: handler });
            seatingStore.setSeatLayout(undefined);
            expect(seatingStore.hasSeatLayoutData).toBe(false);
        });
        it('returns false when seat layout has no areas', function () {
            var handler = new MockSeatSelectionHandlerSuccess();
            var seatingStore = new SeatingStore({ selectSeatHandler: handler });
            var seatLayout = {
                areas: undefined
            };
            seatingStore.setSeatLayout(seatLayout);
            expect(seatingStore.hasSeatLayoutData).toBe(false);
        });
    });
    describe('setErrorMessages', function () {
        it('sets error messages', function () {
            var handler = new MockSeatSelectionHandlerSuccess();
            var seatingStore = new SeatingStore({ selectSeatHandler: handler });
            seatingStore.setErrorMessages([{ ruleName: SeatSelectionRuleName.CannotExceedAllocatedSeatsForAreaCategory, category: SeatingErrorCategory.RuleViolation }]);
            expect(seatingStore.data.errors.slice()).toEqual([{ ruleName: SeatSelectionRuleName.CannotExceedAllocatedSeatsForAreaCategory, category: SeatingErrorCategory.RuleViolation }]);
        });
    });
    describe('clearErrorMessages', function () {
        it('clears any error messages', function () {
            var handler = new MockSeatSelectionHandlerSuccess();
            var seatingStore = new SeatingStore({ selectSeatHandler: handler });
            seatingStore.setErrorMessages([{ ruleName: SeatSelectionRuleName.CannotExceedAllocatedSeatsForAreaCategory, category: SeatingErrorCategory.RuleViolation }]);
            expect(seatingStore.data.errors.slice()).toEqual([{ ruleName: SeatSelectionRuleName.CannotExceedAllocatedSeatsForAreaCategory, category: SeatingErrorCategory.RuleViolation }]);
            seatingStore.clearErrorMessages();
            expect(seatingStore.data.errors.slice()).toEqual([]);
        });
    });
});
//# sourceMappingURL=seating-store.test.js.map