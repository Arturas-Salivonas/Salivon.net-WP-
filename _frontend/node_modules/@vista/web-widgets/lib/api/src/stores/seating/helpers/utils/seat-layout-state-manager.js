import { observable, toJS, transaction } from 'mobx';
import { getAreaCategoryForSeat } from '../../../../mappers/seating/seat-layout-mapper';
import { flattenObservableArray } from '../../../../utils/array-utils';
import { cloneAreaCategory } from './area-utils';
import { getCurrentSeatState } from './seat-layout-state-utils';
import { deselectSeat, selectSeat } from './seat-selection-utils';
import { cloneSeat, getSeatByPosition } from './seat-utils';
/**
 * Handles temporary state changes for the seat layout
 * that allows seats to be selected, validated and the changes
 * to be discarded if the validation fails.
 */
var SeatLayoutStateManager = /** @class */ (function () {
    function SeatLayoutStateManager(seatLayout, _isSeatFirstOrdering, maximumTicketsAllowedInAnOrder) {
        this.seatLayout = seatLayout;
        this._isSeatFirstOrdering = _isSeatFirstOrdering;
        this.maximumTicketsAllowedInAnOrder = maximumTicketsAllowedInAnOrder;
    }
    Object.defineProperty(SeatLayoutStateManager.prototype, "isSeatFirstOrdering", {
        get: function () {
            return this._isSeatFirstOrdering;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SeatLayoutStateManager.prototype, "areaCategories", {
        get: function () {
            return this.seatLayout.areaCategories.map(function (x) { return x.nextState || x; });
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sets the next state to include the selected seat
     * @param seat The selected seat
     * @param areaCategory The area category the seat belongs to
     */
    SeatLayoutStateManager.prototype.selectSeat = function (seat) {
        var areaCategory = getAreaCategoryForSeat(seat, this.seatLayout);
        if (seat.nextState === undefined)
            seat.nextState = cloneSeat(seat);
        if (areaCategory.nextState === undefined)
            areaCategory.nextState = cloneAreaCategory(areaCategory);
        selectSeat(seat.nextState, areaCategory.nextState);
    };
    /**
     * Sets the next state to exclude the deselected seat
     * @param seat The deselected seat
     * @param areaCategory The area category the seat belongs to
     */
    SeatLayoutStateManager.prototype.deselectSeat = function (seat) {
        var areaCategory = getAreaCategoryForSeat(seat, this.seatLayout);
        if (seat.nextState === undefined)
            seat.nextState = toJS(seat);
        if (areaCategory.nextState === undefined)
            areaCategory.nextState = toJS(areaCategory);
        deselectSeat(seat.nextState, areaCategory.nextState);
    };
    /**
     * Returns true if not all seats in the order have been selected yet.
     *
     * @param {AreaCategory} areaCategory
     * @returns {boolean}
     */
    SeatLayoutStateManager.prototype.canAllocateSeat = function (seat) {
        return this.isSeatFirstOrdering
            ? this.isSeatsAllocatedLessThanMaximumAllowed()
            : this.hasSeatsToAllocateInAreaCategory(getAreaCategoryForSeat(seat, this.seatLayout));
    };
    /**
     * Returns the selected seats based on the 'next state' of the seat layout
     * @param seatLayout
     */
    SeatLayoutStateManager.prototype.getSelectedSeats = function () {
        var _this = this;
        return this.getSelectedSeatPositions(this.seatLayout)
            .map(function (x) { return getSeatByPosition(_this.seatLayout, {
            areaNumber: x.areaNumber,
            columnIndex: x.columnIndex,
            rowIndex: x.rowIndex
        }); })
            .filter(function (seat) { return seat !== undefined; });
    };
    /**
     * Returns the seat matching that position
     * @param position
     */
    SeatLayoutStateManager.prototype.getSeatByPosition = function (position) {
        var seat = getSeatByPosition(this.seatLayout, position);
        if (!seat)
            return undefined;
        return getCurrentSeatState(seat);
    };
    /**
     * Updates the seatLayout with any changes made by the selectSeat and
     * deselectSeat methods.
     */
    SeatLayoutStateManager.prototype.applyStateChanges = function () {
        this.flushStateChanges(true);
    };
    /**
     * Discards any changes made by the selectSeat and deselectSeat methods.
     */
    SeatLayoutStateManager.prototype.discardStateChanges = function () {
        this.flushStateChanges(false);
    };
    SeatLayoutStateManager.prototype.hasSeatsToAllocateInAreaCategory = function (areaCategory) {
        var areaCategoryState = this.getAreaCategoryState(areaCategory);
        return areaCategoryState.seatsToAllocate > areaCategoryState.seatsAllocatedCount;
    };
    /**
     * Returns the selected seats based on the 'next state' of the seat layout
     * @param seatLayout
     */
    SeatLayoutStateManager.prototype.getSelectedSeatPositions = function (seatLayout) {
        return this.areaCategories
            .map(function (x) { return (x.nextState || x).selectedSeats; })
            .reduce(flattenObservableArray, observable.array([]));
    };
    SeatLayoutStateManager.prototype.flushStateChanges = function (applyChanges) {
        var _this = this;
        // Wrap in a mobx transaction to avoid multiple updates to any observers while updating the seat layout state
        transaction(function () {
            _this.seatLayout.areaCategories.forEach(function (areaCategory) {
                if (!areaCategory.nextState)
                    return;
                if (applyChanges)
                    Object.assign(areaCategory, areaCategory.nextState);
                delete areaCategory.nextState;
            });
            _this.seatLayout.areas.forEach(function (area) {
                area.rows.forEach(function (row) {
                    row.seats.forEach(function (seat) {
                        if (!seat.nextState)
                            return;
                        if (applyChanges)
                            Object.assign(seat, seat.nextState);
                        delete seat.nextState;
                    });
                });
            });
        });
    };
    SeatLayoutStateManager.prototype.isSeatsAllocatedLessThanMaximumAllowed = function () {
        var _this = this;
        var totalSeatsAllocated = this.seatLayout.areaCategories.reduce(function (acc, ac) { return acc + _this.getAreaCategoryState(ac).seatsAllocatedCount; }, 0);
        return totalSeatsAllocated < this.maximumTicketsAllowedInAnOrder;
    };
    SeatLayoutStateManager.prototype.getAreaCategoryState = function (areaCategory) {
        return areaCategory.nextState
            ? areaCategory.nextState
            : areaCategory;
    };
    return SeatLayoutStateManager;
}());
export { SeatLayoutStateManager };
//# sourceMappingURL=seat-layout-state-manager.js.map