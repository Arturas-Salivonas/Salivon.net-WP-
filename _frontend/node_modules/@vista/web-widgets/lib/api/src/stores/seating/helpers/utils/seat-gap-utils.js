var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import { seatIsCurrentlyAvailable } from './seat-layout-state-utils';
import { getSeatByPosition, seatIsUnavailable } from './seat-utils';
export var Direction;
(function (Direction) {
    Direction[Direction["Left"] = 0] = "Left";
    Direction[Direction["Right"] = 1] = "Right";
})(Direction || (Direction = {}));
export function seatOneSpaceAwayIsAvailable(selectedSeat, seatLayout, direction) {
    var oneSeatOver = getRelativeSeatOnRow(selectedSeat, direction, 1, seatLayout);
    return !!(oneSeatOver && seatIsCurrentlyAvailable(oneSeatOver));
}
export function getSeatTwoSpacesAway(selectedSeat, seatLayout, direction) {
    return getRelativeSeatOnRow(selectedSeat, direction, 2, seatLayout);
}
export function contiguousSeatBlockHasSingleAvailableSeat(seat, seatLayout) {
    var seatsInContiguousBlock = getSeatsUntilAisle(seat, seatLayout, Direction.Left).concat([
        seat
    ], getSeatsUntilAisle(seat, seatLayout, Direction.Right));
    return hasExactlyOneAvailableSeat(seatsInContiguousBlock);
}
export function contiguousSeatSubBlockHasSingleAvailableSeat(seat, seatLayout) {
    var seatsInContiguousSubBlock = getSeatsUntil(seat, seatLayout, Direction.Left, function (seat) { return !!(seat && seatIsUnavailable(seat)); }).concat([
        seat
    ], getSeatsUntil(seat, seatLayout, Direction.Right, function (seat) { return !!(seat && seatIsUnavailable(seat)); }));
    return hasExactlyOneAvailableSeat(seatsInContiguousSubBlock);
}
export function getSeatsUntil(seat, seatLayout, direction, untilFn) {
    var seats = new Array();
    var offset = 1;
    while (true) {
        var nextSeat = getRelativeSeatOnRow(seat, direction, offset, seatLayout);
        if (nextSeat === undefined || untilFn(nextSeat))
            break;
        seats.push(nextSeat);
        offset++;
    }
    return seats;
}
function getSeatsUntilAisle(seat, seatLayout, direction) {
    return getSeatsUntil(seat, seatLayout, direction, function (seat) { return seat === undefined; });
}
function hasExactlyOneAvailableSeat(seats) {
    var availableSeatFound = false;
    for (var _i = 0, seats_1 = seats; _i < seats_1.length; _i++) {
        var currentSeat = seats_1[_i];
        if (seatIsCurrentlyAvailable(currentSeat)) {
            if (availableSeatFound)
                return false;
            availableSeatFound = true;
        }
    }
    return availableSeatFound;
}
function getRelativeSeatOnRow(relativeSeat, direction, relativeOffset, seatLayout) {
    // since the map is inverted - positive increments are left, negative - right
    var directionAdjustment = direction === Direction.Left
        ? 1
        : -1;
    var relativeSeatPosition = __assign({}, relativeSeat.position, { columnIndex: relativeSeat.position.columnIndex + (relativeOffset * directionAdjustment) });
    return getSeatByPosition(seatLayout, relativeSeatPosition);
}
//# sourceMappingURL=seat-gap-utils.js.map