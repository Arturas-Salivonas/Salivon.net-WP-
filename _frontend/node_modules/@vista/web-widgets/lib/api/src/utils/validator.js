import { Logger } from './logger';
var Validator = /** @class */ (function () {
    function Validator() {
        var _this = this;
        this._allowNull = false;
        this._allowUndefined = false;
        this.validateType = function (value, logLabel) {
            if (_this._ofType === undefined) {
                return true;
            }
            var valid;
            switch (_this._ofType) {
                case 'array':
                    valid = Array.isArray(value);
                    break;
                case 'number':
                    valid = typeof value === _this._ofType && !isNaN(value);
                    break;
                case 'object':
                    valid = typeof value === _this._ofType && value !== null;
                    break;
                default:
                    valid = typeof value === _this._ofType;
                    break;
            }
            if (!valid)
                Logger.warn(logLabel + " must be of type '" + _this._ofType + "'");
            return valid;
        };
        this.validateMin = function (value, logLabel) {
            if (_this._min === undefined) {
                return true;
            }
            else if (typeof value !== 'number') {
                Logger.warn(logLabel + " must be a number");
                return false;
            }
            var valid = value >= _this._min;
            if (!valid)
                Logger.warn(logLabel + " cannot be less than " + _this._min);
            return valid;
        };
        this.validateMax = function (value, logLabel) {
            if (_this._max === undefined) {
                return true;
            }
            else if (typeof value !== 'number') {
                Logger.warn(logLabel + " must be a number");
                return false;
            }
            var valid = value <= _this._max;
            if (!valid)
                Logger.warn(logLabel + " cannot be greater than " + _this._max);
            return valid;
        };
        this.hasLength = function (value) {
            if (value === undefined || value === null)
                return false;
            return Array.isArray(value) || typeof value === 'string';
        };
        this.validateMinLength = function (value, logLabel) {
            if (_this._minLength === undefined) {
                return true;
            }
            else if (!_this.hasLength(value)) {
                Logger.warn(logLabel + " must be a string or an array");
                return false;
            }
            var valid = value.length >= _this._minLength;
            if (!valid)
                Logger.warn(logLabel + " cannot be shorter than " + _this._minLength);
            return valid;
        };
        this.validateMaxLength = function (value, logLabel) {
            if (_this._maxLength === undefined) {
                return true;
            }
            else if (!_this.hasLength(value)) {
                Logger.warn(logLabel + " must be a string or an array");
                return false;
            }
            var valid = value.length <= _this._maxLength;
            if (!valid)
                Logger.warn(logLabel + " cannot be longer than " + _this._maxLength);
            return valid;
        };
        this.validateValues = function (value, logLabel) {
            return Array.isArray(value)
                ? value.every(function (value) { return _this.validateValue(value, logLabel); })
                : _this.validateValue(value, logLabel);
        };
        this.validateValue = function (value, logLabel) {
            if (_this._validValues === undefined)
                return true;
            var valid = _this._validValues.includes(value);
            if (!valid)
                Logger.warn(logLabel + " is not a supported value");
            return valid;
        };
    }
    /**
     * Enforces that the value is of a given type.
     */
    Validator.prototype.ofType = function (type) {
        this._ofType = type;
        return this;
    };
    /**
     * Enforces that the value is within a constrained set of values.
     */
    Validator.prototype.includedInValues = function (validValues) {
        this._validValues = validValues;
        return this;
    };
    /**
     * Allow the value to be null.
     */
    Validator.prototype.allowNull = function () {
        this._allowNull = true;
        return this;
    };
    /**
     * Allow the value to be undefined.
     */
    Validator.prototype.allowUndefined = function () {
        this._allowUndefined = true;
        return this;
    };
    /**
     * Enforces that the number is no smaller than a given minimum value.
     * @param min The minimum value that the number can be.
     */
    Validator.prototype.min = function (min) {
        this._min = min;
        return this;
    };
    /**
     * Enforces that the number is no greater than a given maximum value.
     * @param max The maximum value that the number can be.
     */
    Validator.prototype.max = function (max) {
        this._max = max;
        return this;
    };
    /**
     * Enforces that the value's length is no shorter than a given minimum length.
     * @param minLength The minimum length that the value can be.
     */
    Validator.prototype.minLength = function (minLength) {
        this._minLength = minLength;
        return this;
    };
    /**
     * Enforces that the value's length is no longer than a given maximum length.
     * @param maxLength The maximum length that the value can be.
     */
    Validator.prototype.maxLength = function (maxLength) {
        this._maxLength = maxLength;
        return this;
    };
    /**
     * Validates a given value and logs appropriate warnings.
     * @param value The value to be validated.
     * @param logLabel The label to be used when logging warnings.
     */
    Validator.prototype.validate = function (value, logLabel) {
        if (value === null && this._allowNull)
            return true;
        if (value === undefined && this._allowUndefined)
            return true;
        return [
            this.validateType,
            this.validateValues,
            this.validateMin,
            this.validateMax,
            this.validateMinLength,
            this.validateMaxLength
        ].every(function (validatorFn) { return validatorFn(value, logLabel); });
    };
    return Validator;
}());
export { Validator };
//# sourceMappingURL=validator.js.map