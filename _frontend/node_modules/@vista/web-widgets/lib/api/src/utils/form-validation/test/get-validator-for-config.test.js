import * as formFieldValidator from '../form-field-validator';
import { getValidatorForConfig } from '../get-validator-for-config';
import * as stringLengthValidationRule from '../validation-rules/string-length-validation-rule';
import * as regexFormatValidationRule from '../validation-rules/regex-format-validation-rule';
import * as emailFormatValidationRule from '../validation-rules/email-format-validation-rule';
describe('getValidatorForConfig', function () {
    var stringLengthValidationRuleSpy = jest.spyOn(stringLengthValidationRule, 'stringLengthValidationRule');
    var regexFormatValidationRuleSpy = jest.spyOn(regexFormatValidationRule, 'regexFormatValidationRule');
    var emailFormatValidationRuleSpy = jest.spyOn(emailFormatValidationRule, 'emailFormatValidationRule');
    var formFieldValidatorSpy = jest.spyOn(formFieldValidator, 'FormFieldValidator');
    var mockAddValidationRule = jest.fn();
    formFieldValidatorSpy.mockImplementation(function () {
        return { addValidationRule: mockAddValidationRule };
    });
    var testKey = 'test';
    beforeEach(function () {
        stringLengthValidationRuleSpy.mockClear();
        regexFormatValidationRuleSpy.mockClear();
        emailFormatValidationRuleSpy.mockClear();
        formFieldValidatorSpy.mockClear();
        mockAddValidationRule.mockClear();
    });
    describe('fieldValidationConfig', function () {
        describe('requiredValidationRule', function () {
            var _loop_1 = function (isRequired) {
                it("correctly constructs FormFieldValidator when required is " + isRequired, function () {
                    getValidatorForConfig(testKey, { required: isRequired });
                    expect(formFieldValidatorSpy).toHaveBeenCalledWith(testKey, isRequired);
                });
            };
            for (var _i = 0, _a = [true, false]; _i < _a.length; _i++) {
                var isRequired = _a[_i];
                _loop_1(isRequired);
            }
        });
        describe('customValidationRule', function () {
            it('can add a custom validation rule', function () {
                var customValidationRule = function () { return 'awefawef'; };
                getValidatorForConfig(testKey, {
                    customValidation: customValidationRule,
                    required: false,
                });
                expect(mockAddValidationRule).toHaveBeenLastCalledWith(customValidationRule);
            });
            var invalidCustomValidationRules = [{}, undefined, null, 1, '1'];
            var _loop_2 = function (invalidRule) {
                it('does not add a non-function', function () {
                    getValidatorForConfig(testKey, {
                        customValidation: invalidRule,
                        required: false,
                    });
                    expect(mockAddValidationRule).not.toHaveBeenCalled();
                });
            };
            for (var _i = 0, invalidCustomValidationRules_1 = invalidCustomValidationRules; _i < invalidCustomValidationRules_1.length; _i++) {
                var invalidRule = invalidCustomValidationRules_1[_i];
                _loop_2(invalidRule);
            }
        });
    });
    describe('textFieldValidationConfig', function () {
        it('can make a validator given a text field validation config', function () {
            getValidatorForConfig(testKey, {
                required: true,
                customValidation: function () { return ''; },
                minLength: 1,
                maxLength: 1,
                format: 'email',
            });
            expect(mockAddValidationRule).toBeCalledTimes(3);
        });
        describe('stringLengthValidationRule', function () {
            var testCases = [
                { minLength: -1, maxLength: 0, shouldHaveRule: false },
                { minLength: 0, maxLength: -92, shouldHaveRule: false },
                { minLength: 0, maxLength: 0, shouldHaveRule: false },
                { minLength: 1, maxLength: 0, shouldHaveRule: true },
                { minLength: -1, maxLength: 1, shouldHaveRule: true },
                { minLength: 5, maxLength: 10, shouldHaveRule: true },
            ];
            var _loop_3 = function (testCase) {
                it((testCase.shouldHaveRule ? '' : 'doesn\'t') + " add a rule for minLength " + testCase.minLength + " and maxLength " + testCase.maxLength, function () {
                    getValidatorForConfig(testKey, {
                        format: '',
                        minLength: testCase.minLength,
                        maxLength: testCase.maxLength,
                    });
                    expect(mockAddValidationRule).toHaveBeenCalledTimes(testCase.shouldHaveRule ? 1 : 0);
                });
            };
            for (var _i = 0, testCases_1 = testCases; _i < testCases_1.length; _i++) {
                var testCase = testCases_1[_i];
                _loop_3(testCase);
            }
            var invalidLengths = [-999, -1, 0];
            var validLength = 1;
            var _loop_4 = function (invalidLength) {
                it("casts invalid minLength " + invalidLength + " to zero", function () {
                    getValidatorForConfig(testKey, {
                        format: '',
                        minLength: invalidLength,
                        maxLength: validLength,
                    });
                    expect(stringLengthValidationRuleSpy).toHaveBeenCalledWith(testKey, 0, validLength);
                });
                it("casts invalid maxLength " + invalidLength + " to infinity", function () {
                    getValidatorForConfig(testKey, {
                        format: '',
                        minLength: validLength,
                        maxLength: invalidLength,
                    });
                    expect(stringLengthValidationRuleSpy).toHaveBeenCalledWith(testKey, validLength, Infinity);
                });
            };
            for (var _a = 0, invalidLengths_1 = invalidLengths; _a < invalidLengths_1.length; _a++) {
                var invalidLength = invalidLengths_1[_a];
                _loop_4(invalidLength);
            }
        });
        describe('formatValidationRule', function () {
            it('adds a regex format rule when format is a regex', function () {
                var regex = /a/;
                getValidatorForConfig(testKey, {
                    format: /a/,
                });
                expect(mockAddValidationRule).toHaveBeenCalledTimes(1);
                expect(regexFormatValidationRuleSpy).toHaveBeenCalledWith(testKey, regex);
                expect(emailFormatValidationRuleSpy).not.toHaveBeenCalled();
            });
            it("adds a email format rule when format is 'email'", function () {
                getValidatorForConfig(testKey, {
                    format: 'email',
                });
                expect(mockAddValidationRule).toHaveBeenCalledTimes(1);
                expect(regexFormatValidationRuleSpy).not.toHaveBeenCalled();
                expect(emailFormatValidationRuleSpy).toHaveBeenCalledWith(testKey);
            });
            it("does not add a rule when format is an empty string", function () {
                getValidatorForConfig(testKey, {
                    format: '',
                });
                expect(mockAddValidationRule).not.toHaveBeenCalled();
            });
            it('does not add a rule for an unknown format type', function () {
                getValidatorForConfig(testKey, {
                    format: 'credit card',
                });
                expect(mockAddValidationRule).not.toHaveBeenCalled();
            });
        });
    });
});
//# sourceMappingURL=get-validator-for-config.test.js.map