import { serializer } from '../utils/serialisation/serializer';
// key string separator
var KEY_SEPARATOR = '::';
// Prefix for all LSCacheService keys
var DEFAULT_CACHE_PREFIX = 'LSCache' + KEY_SEPARATOR;
// Default storage engine
var DEFAULT_STORAGE_ENGINE = sessionStorage;
// Suffix for the key name on the expiration items in selected storage engine
var CACHE_SUFFIX = KEY_SEPARATOR + 'cache-expiration';
// expiration date radix (set to Base-36 for most space savings)
var EXPIRY_RADIX = 10;
// time resolution in milliseconds
var EXPIRY_UNITS = 1;
// ECMAScript max Date (epoch + 1e8 days)
var MAX_DATE = Math.floor(8.64e15 / EXPIRY_UNITS);
/**
 * Cache service class
 *
 * Persists data using session or local storage.
 * Based on Pamela Fox's LSCache library (https://github.com/pamelafox/LSCache)
 */
var CacheService = /** @class */ (function () {
    function CacheService(cachePrefix, storageEngine) {
        if (cachePrefix === void 0) { cachePrefix = DEFAULT_CACHE_PREFIX; }
        if (storageEngine === void 0) { storageEngine = DEFAULT_STORAGE_ENGINE; }
        this.cachePrefix = cachePrefix;
        this.storageEngine = storageEngine;
        this.cacheBucket = '';
        this.warnings = false;
        this.hasRun = false;
        //
    }
    /**
     * Allows usage of a different storage engine, if no data has already been stored
     * localStorage and sessionStorage supported
     * Note: no tests available as no Storage primitive can be used with jest so far
     * @param {Storage} engine
     */
    CacheService.prototype.setStorageEngine = function (engine) {
        if (!(engine instanceof Storage)) {
            throw new Error("Provided storage engine is not matching type 'Storage', defaults will be applied");
        }
        if (!this.hasRun) {
            throw new Error("Storage service has already been used, it cannot be changed unless it's flushed.");
        }
        this.storageEngine = engine;
    };
    /**
     * Stores the value in selected storage engine.
     * Expires after specified number of milliseconds.
     * @param {string} key
     * @param {Object|string} value
     * @param {number} time
     */
    CacheService.prototype.set = function (key, value, time) {
        var _this = this;
        if (!this.supportsStorage()) {
            return;
        }
        var serialisedValue = serializer.stringify(value);
        try {
            this.setItem(key, serialisedValue);
        }
        catch (e) {
            if (!this.isOutOfSpace(e)) {
                // If it was some other error, just give up.
                if (this.warnings) {
                    console.warn("Could not add item with key " + key, e);
                }
                return;
            }
            // If we exceeded the quota, then we will sort
            // by the expire time, and then remove the N oldest
            var storedKeys_1 = [];
            var storedKey = void 0;
            this.eachKey(function (thisKey, exprKey) {
                var expiration = _this.getItem(exprKey);
                if (expiration) {
                    expiration = parseInt(expiration, EXPIRY_RADIX);
                }
                else {
                    // MAX_DATE default added for non-expiring items
                    expiration = MAX_DATE;
                }
                storedKeys_1.push({
                    key: thisKey,
                    size: (_this.getItem(thisKey) || '').length,
                    expiration: expiration
                });
            });
            // Sorts the keys with oldest expiration time last
            storedKeys_1.sort(function (a, b) { return (b.expiration - a.expiration); });
            var targetSize = (serialisedValue || '').length;
            while (storedKeys_1.length && targetSize > 0) {
                storedKey = storedKeys_1.pop();
                if (this.warnings) {
                    console.warn("Cache is full, removing item with key " + key);
                }
                this.flushItem(storedKey.key);
                targetSize -= storedKey.size;
            }
            try {
                this.setItem(key, serialisedValue);
            }
            catch (e) {
                // value may be larger than total quota
                if (this.warnings) {
                    console.warn("Could not add item with key " + key + ", perhaps it's too big?", e);
                }
                return;
            }
        }
        // If a time is specified, store expiration info in selected storage engine
        if (time) {
            this.setItem(this.expirationKey(key), (this.currentTime() + time).toString(EXPIRY_RADIX));
        }
        else {
            // In case they previously set a time, remove that info from selected storage engine.
            this.removeItem(this.expirationKey(key));
        }
    };
    /**
     * Retrieves specified value from selected storage engine, if not expired.
     * @param {string} key
     * @return {string|Object}
     */
    CacheService.prototype.get = function (key) {
        if (!this.supportsStorage()) {
            return null;
        }
        // Return the de-serialized item if not expired
        if (this.flushExpiredItem(key)) {
            return null;
        }
        var valueRaw = this.getItem(key);
        return serializer.parse(valueRaw);
    };
    /**
     * Removes a value from selected storage engine.
     * Equivalent to 'delete' in memcache, but that's a keyword in JS.
     * @param {string} key
     */
    CacheService.prototype.remove = function (key) {
        if (!this.supportsStorage()) {
            return;
        }
        this.flushItem(key);
    };
    /**
     * Flushes all LSCacheService items and expiry markers without affecting rest of selected storage engine
     */
    CacheService.prototype.flush = function () {
        var _this = this;
        if (!this.supportsStorage()) {
            return;
        }
        this.eachKey(function (key) {
            _this.flushItem(key);
        });
        this.hasRun = false;
    };
    /**
     * Flushes expired LSCacheService items and expiry markers without affecting rest of selected storage engine
     */
    CacheService.prototype.flushExpired = function () {
        var _this = this;
        if (!this.supportsStorage()) {
            return;
        }
        this.eachKey(function (key) {
            _this.flushExpiredItem(key);
        });
        this.hasRun = true;
    };
    /**
     * Appends CACHE_PREFIX so LSCacheService will partition data in to different buckets.
     * @param {string} bucket
     */
    CacheService.prototype.setBucket = function (bucket) {
        this.cacheBucket = bucket + KEY_SEPARATOR;
    };
    /**
     * Resets the string being appended to CACHE_PREFIX so LSCacheService will use the default storage behavior.
     */
    CacheService.prototype.resetBucket = function () {
        this.cacheBucket = '';
    };
    /**
     * Sets whether to display warnings when an item is removed from the cache or not.
     */
    CacheService.prototype.enableWarnings = function (enabled) {
        this.warnings = enabled;
    };
    /**
     * Determines if selected storage engine is supported in the browser.
     * Result is cached for better performance instead of being run each time.
     * Feature detection is based on how Modernizr does it;
     * todo: even if the returned result lives in memory once run for the first time, this is quite a slow method!
     * todo: we might want to suppress or exclude by configuration at some point.
     * @returns {boolean}
     */
    CacheService.prototype.supportsStorage = function () {
        var key = '__LSCacheServicetest__';
        var value = key;
        /* tslint:disable */
        if (typeof this.cachedStorage !== 'undefined') {
            return this.cachedStorage;
        }
        /* tslint:enable */
        // some browsers will throw an error if you try to access local storage (e.g. brave browser)
        // hence check is inside a try/catch
        try {
            if (!this.storageEngine) {
                return false;
            }
        }
        catch (ex) {
            return false;
        }
        try {
            this.setItem(key, value);
            this.removeItem(key);
            this.cachedStorage = true;
        }
        catch (e) {
            // If we hit the limit, and we don't have an empty selected storage engine then it means we have support
            this.cachedStorage = this.isOutOfSpace(e) && this.storageEngine.length > 0;
        }
        return this.cachedStorage;
    };
    /**
     * Check to set if the error is us dealing with being out of space
     * @param e
     * @returns {boolean}
     */
    CacheService.prototype.isOutOfSpace = function (e) {
        return e && e.name === 'QUOTA_EXCEEDED_ERR' ||
            e.name === 'NS_ERROR_DOM_QUOTA_REACHED' ||
            e.name === 'QuotaExceededError';
    };
    /**
     * Returns a string where all RegExp special characters are escaped with a \.
     * @param {String} text
     * @return {string}
     */
    CacheService.prototype.escapeRegExpSpecialCharacters = function (text) {
        return text.replace(/[[\]{}()*+?.\\^$|]/g, '\\$&');
    };
    /**
     * Returns the full string for the selected storage engine expiration item.
     * @param {String} key
     * @return {string}
     */
    CacheService.prototype.expirationKey = function (key) {
        return key + CACHE_SUFFIX;
    };
    /**
     * Returns the number of expiry units (ms) since the epoch.
     * @return {number}
     */
    CacheService.prototype.currentTime = function () {
        return Math.floor(Date.now() / EXPIRY_UNITS);
    };
    /**
     * Wrapper functions for selected storage engine methods
     */
    CacheService.prototype.getItem = function (key) {
        return this.storageEngine.getItem(this.cachePrefix + this.cacheBucket + key);
    };
    CacheService.prototype.setItem = function (key, value) {
        // Fix for iPad issue - sometimes throws QUOTA_EXCEEDED_ERR on setItem.
        this.storageEngine.removeItem(this.cachePrefix + this.cacheBucket + key);
        this.storageEngine.setItem(this.cachePrefix + this.cacheBucket + key, value);
        this.hasRun = true;
    };
    CacheService.prototype.removeItem = function (key) {
        this.storageEngine.removeItem(this.cachePrefix + this.cacheBucket + key);
        this.hasRun = true;
    };
    CacheService.prototype.eachKey = function (fn) {
        var prefixRegExp = new RegExp('^' + this.cachePrefix + this.escapeRegExpSpecialCharacters(this.cacheBucket) + '(.*)');
        // Loop in reverse as removing items will change indices of tail
        for (var i = this.storageEngine.length - 1; i >= 0; --i) {
            var key = this.storageEngine.key(i);
            key = key && key.match(prefixRegExp);
            key = key && key[1];
            if (key && key.indexOf(CACHE_SUFFIX) < 0) {
                fn(key, this.expirationKey(key));
            }
        }
    };
    CacheService.prototype.flushItem = function (key) {
        var exprKey = this.expirationKey(key);
        this.removeItem(key);
        this.removeItem(exprKey);
        this.hasRun = true;
    };
    CacheService.prototype.flushExpiredItem = function (key) {
        var exprKey = this.expirationKey(key);
        var expr = this.getItem(exprKey);
        if (expr) {
            var expirationTime = parseInt(expr, EXPIRY_RADIX);
            // Check if we should actually kick item out of storage
            if (this.currentTime() >= expirationTime) {
                this.removeItem(key);
                this.removeItem(exprKey);
                return true;
            }
        }
        return false;
    };
    return CacheService;
}());
export { CacheService };
export var cacheServiceInstance = new CacheService('VistaWebWidgets' + KEY_SEPARATOR);
//# sourceMappingURL=cache-service.js.map