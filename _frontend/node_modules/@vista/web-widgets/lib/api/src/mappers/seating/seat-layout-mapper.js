var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import { MxSeatStatus } from '../../../../mx-api-client/src/mxt/types/seating/seat-status';
import { SeatAvailability as WidgetSeatAvailability } from '../../../../types/seating/seat-availability';
import { SeatType as WidgetSeatType } from '../../../../types/seating/seat-type';
/**
 * Creates referential links between each seating property, i.e.
 * can navigate directly between a seat, its parent row, area, and
 * area category.
 *
 * Intended to be used after loading the JSON seating layout, which
 * has no circular dependencies.
 *
 * @export
 * @param {SeatLayout} seatLayout
 * @hidden
 */
export function mapMxSeatLayoutToWidgetSeatLayout(seatLayout) {
    return __assign({}, seatLayout, { areas: seatLayout.areas.map(function (area) { return mapArea(area, seatLayout); }) });
}
/**
 *  Maps area object from the API to the area object expected by the service.
 *
 * @param {MxArea} area
 * @param {MxSeatLayout} seatLayout
 * @returns {Area}
 * @hidden
 */
function mapArea(area, seatLayout) {
    return __assign({}, area, { rows: area.rows.map(function (row) { return mapRow(row, area); }) });
}
/**
 *  Maps row object from the API to the row object expected by the service.
 *
 * @param {MxRow} row
 * @param {Area} area
 * @returns {Row}
 * @hidden
 */
function mapRow(row, area) {
    var rowIndex = Array.isArray(row.seats) && row.seats.length > 0 ? (row.seats[0].position && row.seats[0].position.rowIndex) : -1;
    return __assign({}, row, { areaNumber: area.number, seats: row.seats.map(function (seat) { return mapSeat(seat, area); }), rowIndex: rowIndex });
}
/**
 *  Maps seat object from the API to the seat object expected by the service.
 *
 * @param {MxSeat} seat
 * @param {Row} row
 * @param {Area} area
 * @returns {Seat}
 * @hidden
 */
function mapSeat(seat, area) {
    return __assign({}, seat, { areaCategoryCode: area.areaCategoryCode, availability: mapStatusToAvailability(seat.status), type: mapSeatType(seat) });
}
/**
 * Maps seat status from the API to SeatAvailability type expected by the service.
 * SeatStatus from API combines both availability and seat type.
 * This function splits the availability information into its own type.
 * @param {SeatStatus} seatStatus
 * @returns {SeatAvailability}
 * @hidden
 */
function mapStatusToAvailability(seatStatus) {
    switch (seatStatus) {
        case MxSeatStatus.Empty:
        case MxSeatStatus.Wheelchair:
        case MxSeatStatus.Companion:
            return WidgetSeatAvailability.Available;
        case MxSeatStatus.Sold:
            return WidgetSeatAvailability.Sold;
        case MxSeatStatus.Broken:
            return WidgetSeatAvailability.Broken;
        case MxSeatStatus.Selected:
            return WidgetSeatAvailability.Selected;
        default:
            return WidgetSeatAvailability.Sold;
    }
}
/**
 * Determines the type of a seat from the Seat API data.
 * Seats with an original status of Companion or Wheelchair will have a type of Companion or Wheelchair respectively.
 * Non-Wheelchair/Companion seats that belong to a group are Sofa seats.
 * All other seats are Normal seats.
 * @param {SeatStatus} seatStatus
 * @returns {SeatType}
 * @hidden
 */
function mapSeatType(seat) {
    var originalStatus = seat.originalStatus, seatsInGroup = seat.seatsInGroup, position = seat.position;
    if (originalStatus === MxSeatStatus.Companion)
        return WidgetSeatType.Companion;
    if (originalStatus === MxSeatStatus.Wheelchair)
        return WidgetSeatType.Wheelchair;
    // Seats that are not in a group or wheelchair/companion seats are normal seats.
    if (!seatsInGroup || seatsInGroup.length === 0)
        return WidgetSeatType.Normal;
    // All other seats are sofa seats
    // Sort the column indexes of the group
    var columnIndexes = seatsInGroup.map(function (p) { return p.columnIndex; }).sort(function (a, b) { return a - b; });
    // First seat in the group is the left seat.
    if (position.columnIndex === columnIndexes[0])
        return WidgetSeatType.SofaLeft;
    // Last seat in the group is the right seat.
    if (position.columnIndex === columnIndexes[columnIndexes.length - 1])
        return WidgetSeatType.SofaRight;
    // Others are middle seats.
    return WidgetSeatType.SofaMiddle;
}
/**
 * Returns an area category given a specific seat (if exists in the current layout)
 * @param {Seat} seat
 * @param {SeatLayout} seatLayout
 * @returns {AreaCategory | void}
 * @hidden
 */
export function getAreaCategoryForSeat(seat, seatLayout) {
    var areaCategory = seatLayout.areaCategories.find(function (x) { return x.areaCategoryCode === seat.areaCategoryCode; });
    if (!areaCategory) {
        throw new Error("Area Category look up by seat with code (" + seat.areaCategoryCode + ") does not exist in the seat layout");
    }
    return areaCategory;
}
//# sourceMappingURL=seat-layout-mapper.js.map