import { Dictionary } from './../types/dictionary';
import { Configuration } from './models/configuration';
import { LogProvider } from './models/provider';
/**
 * Vista Diagnostics Log
 *
 * Provides a wrapper for console.log with support for:
 * - configurable threshold level to contain console pollution in different environments
 * - tagged entries for discrete debug, regardless of the above
 * - remote persistence via configurable XHR end point and payload mapping configuration
 *
 * Example #1 - import in your code:
 * ```
 * import { VistaDiagnosticsLog } from '@vista/diagnostics';
 *
 * const log = new VistaDiagnosticsLog();
 * ```
 *
 * Example #2 - use threshold:
 * ```
 * // configure log to only display errors
 * log.configure('console', {
 *     thresholdLevel: ThresholdLevel.ERROR // (4)
 * });
 *
 * // log info
 * log.info('Test message with arguments', {one: 1});
 *
 * // no console output
 * ```
 *
 * Example #3 - use discrete debug with tags:
 * ```
 * // change debug
 * log.debugByTag('security');
 *
 * // first approach, multiple entries in a class or file
 * const securityLog = log.tag(['security']);
 * // call one
 * securityLog.info('Test tagged message');
 * // call two
 * sceurityLog.warn('Oops! Something is not completely right');
 *
 * // second approach - one off chained version
 * log.tag(['security', 'login'])
 *    .info('Test message with arguments', {one: 1});
 *
 * // both will output to console, because tag match
 * ```
 */
export declare class VistaDiagnosticsLog {
    private _configuration;
    private _providers;
    private _debugByTagPool;
    /**
     * Creates a new entry (or extends default values) configuration section
     * matching provided key
     */
    configure(name: string, newConfigurationSection: Dictionary): Configuration;
    /**
     * After any error gets thrown, this provides forwarding of the message and context to log.error
     * By defaults system errors will be suppressed.
     */
    includeGlobalErrors(suppressSystemError?: boolean): void;
    /**
     * Allows for registration of a new log provider that will be added to the stack
     * and invoked when new entries will be logged.
     */
    registerProvider(name: string, provider: LogProvider, configuration: Dictionary): Configuration | void;
    /**
     * Turns on discrete tag based debugging
     * by adding actively filtered tags for log entries to come.
     * An empty payload will turn the tag filtering off.
     * @param tag
     */
    debugByTag(tags?: string | string[]): string[];
    /**
     * Adds one or more tags to next log entry's context,
     * returns a context-aware list of console wrappers for main methods:
     * `trace`, `debug`, `info`, `warn`, `error`.
     *
     * Example with multiple calls:
     * ```
     * const taggedLog = log.tag('example');
     * taggedLog.info('Test message');
     * taggedLog.warn('Test warning');
     * ```
     *
     * Example with chaining:
     * ```
     * log.tag('example')
     *    .info('Test message');
     * ```
     *
     * @param tags
     */
    tag(tags: string | string[]): any;
    /**
     * Trace wrapper
     *
     * @param message
     * @param args
     */
    trace(message: string, ...args: any[]): void;
    /**
     * Debug wrapper
     *
     * @param message
     * @param args
     */
    debug(message: string, ...args: any[]): void;
    /**
     * Info wrapper
     *
     * @param message
     * @param args
     */
    info(message: string, ...args: any[]): void;
    /**
     * Warn wrapper
     *
     * @param message
     * @param args
     */
    warn(message: string, ...args: any[]): void;
    /**
     * Error wrapper
     *
     * @param message
     * @param args
     */
    error(message: string, ...args: any[]): void;
    /**
     * Logs and optionally persist remotely entry depending on threshold and tag matching
     */
    private logEntry;
}
